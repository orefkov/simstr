<html>
<head>
    <meta charset="UTF-8" />
    <link href="results.css" rel="stylesheet" />
    <title>SimStr benchmarks results</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let bench_sets = {};
        let activeBuilder = buildTestsByPlatformsBar;
        let buildAsLine = {
            "Copy not literal Str with N symbols": "Length of the copied string",
            "Replace All Str To Longer Size": "Length of the string to be replaced",
            "Replace All Str To Same Size": "Length of the string to be replaced"
        };
        function hl() {
            document.querySelectorAll('.tooltiptext.code').forEach((el) => {
                hljs.highlightElement(el);
            });
        }
        function addBarChart(id, data) {
            let canvas = document.getElementById('chart' + id);
            new Chart(canvas, {
                type: 'bar',
                data: data,
                options: {
                    scales: {
                        y: {
                            beginAtZero: true
                        },
                        x: {
                            title: {
                                text: "Time (ns)",
                                display: true
                            }
                        }
                    },
                    indexAxis: 'y',
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                font: {
                                    family: "'Cascadia Code', Consolas, 'Courier New', Courier, monospace"
                                }
                            }
                        }
                    }
                }
            });
        }
        function platformChecked(idx) {
            return document.getElementById('pl' + idx).checked;
        }
        function buildPlatformsByTestsBar(bsName) {
            if (buildAsLine[bsName]) {
                buildPlatformsByTestsLine(bsName, buildAsLine[bsName]);
                return;
            }
            let data = { labels: [], datasets: [] };
            for (const i in platform_names) {
                if (platformChecked(i))
                    data.datasets.push({ label: platform_names[i], data: [], borderWidth: 1 });
            }
            let bs = bench_sets[bsName];
            for (const test of bs.tests) {
                data.labels.push(test.name);
                let ds = 0;
                for (const i in test.data) {
                    if (platformChecked(i)) {
                        data.datasets[ds++].data.push(test.data[i]);
                    }
                }
            }
            addBarChart(bs.id, data);
        }
        function buildTestsByPlatformsBar(bsName) {
            if (buildAsLine[bsName], buildAsLine[bsName]) {
                buildTestsByPlatformsLine(bsName, buildAsLine[bsName]);
                return;
            }
            let data = { labels: [], datasets: [] };
            let bs = bench_sets[bsName];
            for (const test of bs.tests) {
                data.datasets.push({ label: test.name, data: [], borderWidth: 1 });
            }
            for (const i in platform_names) {
                if (platformChecked(i)) {
                    data.labels.push(platform_names[i]);
                    for (const j in bs.tests) {
                        data.datasets[j].data.push(bs.tests[j].data[i]);
                    }
                }
            }
            addBarChart(bs.id, data);
        }
        function buildCanvas(plCount) {
            document.querySelectorAll("canvas.bench_chart").forEach(e => e.remove());
            for (var bs_name in bench_sets) {
                let bs = bench_sets[bs_name];
                if (plCount) {
                    let canvas = document.createElement('canvas');
                    canvas.id = "chart" + bs.id;
                    canvas.classList.add('bench_chart');
                    let h = 20 * plCount * bs.tests.length;
                    canvas.style.width = "100%";
                    canvas.style.height = h + "px";
                    canvas.height = h * devicePixelRatio;
                    document.getElementById(bs.id).after(canvas);
                }
            }
        }
        function addLineChart(canvas, data, title, scaleTitle) {
            new Chart(canvas, {
                type: 'line',
                data: data,
                options: {
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                text: scaleTitle,
                                display: true
                            }
                        },
                        x: {
                            title: {
                                text: "Time (ns)",
                                display: true
                            }
                        }
                    },
                    indexAxis: 'y',
                    plugins: {
                        title: {
                            display: true,
                            text: title,
                        },
                        legend: {
                            position: 'right',
                            labels: {
                                font: {
                                    family: "'Cascadia Code', Consolas, 'Courier New', Courier, monospace"
                                }
                            }
                        }
                    }
                }
            });
        }
        function buildTestsByPlatformsLineOne(bs, canvas, plIdx, scaleTitle) {
            let data = { datasets: [] };
            let prevTest = '';
            let curData = undefined;
            for (const test of bs.tests) {
                let m = test.name.match(/(.+)[\/\|](\d+)$/);
                if (m[1] != prevTest) {
                    prevTest = m[1];
                    curData = { label: prevTest, data: [], borderWidth: 1 };
                    data.datasets.push(curData);
                }
                curData.data.push([test.data[plIdx], m[2]]);
            }
            addLineChart(canvas, data, platform_names[plIdx], scaleTitle);
        }
        function buildTestsByPlatformsLine(bsName, scaleTitle) {
            let bs = bench_sets[bsName];
            let canvas = document.getElementById('chart' + bs.id);
            let after = null;

            for (const i in platform_names) {
                if (platformChecked(i)) {
                    if (!canvas) {
                        canvas = document.createElement('canvas');
                        canvas.classList.add('bench_chart');
                        canvas.style.width = "100%";
                        after.after(canvas);
                    }
                    canvas.style.height = "300px";
                    canvas.height = 300 * devicePixelRatio;
                    buildTestsByPlatformsLineOne(bs, canvas, i, scaleTitle);
                    after = canvas;
                    canvas = null;
                }
            }
        }
        function buildPlatformsByTestsLineOne(bs, canvas, after, testData, title, scaleTitle) {
            let data = { datasets: [] };
            for (const i in platform_names) {
                if (platformChecked(i)) {
                    ds = {label: platform_names[i], data: []};
                    for (const test of testData) {
                        ds.data.push([test.data[i], test.count]);
                    }
                    data.datasets.push(ds);
                }
            }
            if (!canvas) {
                canvas = document.createElement('canvas');
                canvas.classList.add('bench_chart');
                canvas.style.width = "100%";
                after.after(canvas);
            }
            canvas.style.height = "300px";
            canvas.height = 300 * devicePixelRatio;
            addLineChart(canvas, data, title, scaleTitle);
            return canvas;
        }
        function buildPlatformsByTestsLine(bsName, scaleTitle) {
            let bs = bench_sets[bsName];
            let canvas = document.getElementById('chart' + bs.id);
            let after = null;
            let data = [];
            let prevTest = '';
            for (const test of bs.tests) {
                let m = test.name.match(/(.+)[\/\|](\d+)$/);
                if (m[1] != prevTest) {
                    if (data.length) {
                        after = buildPlatformsByTestsLineOne(bs, canvas, after, data, prevTest, scaleTitle);
                        canvas = null;
                    }
                    prevTest = m[1];
                    data = [];
                }
                data.push({count: m[2], data: test.data});
            }
            if (data.length) {
                buildPlatformsByTestsLineOne(bs, canvas, after, data, prevTest, scaleTitle);
            }
        }
        function buildCharts() {
            let plCount = 0;
            for (const i in platform_names) {
                if (platformChecked(i))
                    plCount++;
            }
            buildCanvas(plCount);
            for (var bs_name in bench_sets) {
                activeBuilder(bs_name);
            }
        }
        function switchGrouping() {
            activeBuilder = document.getElementById('gbp').checked ? buildTestsByPlatformsBar : buildPlatformsByTestsBar;
            buildCharts();
        }
        document.addEventListener('DOMContentLoaded', (event) => {
            if (!hljs) {
                let scriptTag = document.createElement('script');
                scriptTag.src = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js";
                scriptTag.onload = hl;
                scriptTag.onreadystatechange = hl;
                document.body.appendChild(scriptTag);
            } else {
                hl();
            }
            if (!Chart) {
                let scriptTag = document.createElement('script');
                scriptTag.src = "https://cdn.jsdelivr.net/npm/chart.js";
                scriptTag.onload = buildCharts;
                scriptTag.onreadystatechange = buildCharts;
                document.body.appendChild(scriptTag);
            } else {
                buildCharts();
            }
        });
    </script>
</head><body><div class="header"><h2>SimStr benchmarks results</h2>
<span>All times in ns.</span>
<span><a href="https://github.com/orefkov/simstr/blob/main/bench/bench_str.cpp">Source for benchmarks</a></span>
<div>Group tests by platforms in charts: <input type="checkbox" id="gbp" checked onchange="switchGrouping()"/></div><div class="test_platforms"><h3>Test configurations:</h3><ul>
<li><span class="platform">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</span><span class="tooltip">32 X 2494.22 MHz CPU s<span class="tooltiptext">CPU Caches:
  L1 Data 32 KiB (x16)
  L1 Instruction 32 KiB (x16)
  L2 Unified 256 KiB (x16)
  L3 Unified 40960 KiB (x1)
Load Average: 0.02, 0.47, 0.66
***WARNING*** ASLR is enabled, the results may have unreproducible noise in them.</span></span>&nbsp;Include in charts: <input type="checkbox" id="pl0" checked onchange="buildCharts()"/></li>
<li><span class="platform">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</span><span class="tooltip">32 X 2494.22 MHz CPU s<span class="tooltiptext">CPU Caches:
  L1 Data 32 KiB (x16)
  L1 Instruction 32 KiB (x16)
  L2 Unified 256 KiB (x16)
  L3 Unified 40960 KiB (x1)
Load Average: 0.05, 0.01, 0.00
***WARNING*** ASLR is enabled, the results may have unreproducible noise in them.</span></span>&nbsp;Include in charts: <input type="checkbox" id="pl1" checked onchange="buildCharts()"/></li>
<li><span class="platform">Xeon E5-2682 v4, Windows 10, Clang-19</span><span class="tooltip">32 X 2494 MHz CPU s<span class="tooltiptext">CPU Caches:
  L1 Data 32 KiB (x16)
  L1 Instruction 32 KiB (x16)
  L2 Unified 256 KiB (x16)
  L3 Unified 40960 KiB (x1)</span></span>&nbsp;Include in charts: <input type="checkbox" id="pl2" checked onchange="buildCharts()"/></li>
<li><span class="platform">Xeon E5-2682 v4, Windows 10, MSVC-19</span><span class="tooltip">32 X 2494 MHz CPU s<span class="tooltiptext">CPU Caches:
  L1 Data 32 KiB (x16)
  L1 Instruction 32 KiB (x16)
  L2 Unified 256 KiB (x16)
  L3 Unified 40960 KiB (x1)</span></span>&nbsp;Include in charts: <input type="checkbox" id="pl3" checked onchange="buildCharts()"/></li>
<li><span class="platform">Xeon E5-2682 v4, WASM Firefox, Clang-21</span><span class="tooltip">32 X 2513.96 MHz CPU s<span class="tooltiptext">Firefox: 146.0.1.60 webasm</span></span>&nbsp;Include in charts: <input type="checkbox" id="pl4" checked onchange="buildCharts()"/></li>
</ul></div></div>
<script>const platform_names=['Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21','Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13','Xeon E5-2682 v4, Windows 10, Clang-19','Xeon E5-2682 v4, Windows 10, MSVC-19','Xeon E5-2682 v4, WASM Firefox, Clang-21'];</script>


<div class="benchset" id="bs1"><h4><a id="bs70109915512075798510" href="#bs70109915512075798510">#</a>&nbsp;Concatenate string + Number + &quot;Literal&quot;</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">Concat std::string and number by std to std::string<span class="tooltiptext code">void ConcatStdToStd(benchmark::State&amp; state) {
    std::string s1 = &quot;start &quot;;
    for (auto _: state) {
        for (int i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            std::string str = s1 + std::to_string(i) + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">209</td><td class="benchmarkresult">199</td><td class="benchmarkresult">268</td><td class="benchmarkresult">313</td><td class="benchmarkresult">902</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat std::string and number by StrExpr to std::string<span class="tooltiptext code">void ConcatSimToStd(benchmark::State&amp; state) {
    std::string s1 = &quot;start &quot;;
    for (auto _: state) {
        for (int i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            std::string str = +s1 + i + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">107</td><td class="benchmarkresult">94.7</td><td class="benchmarkresult">154</td><td class="benchmarkresult">210</td><td class="benchmarkresult">401</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat stringa and number by StrExpr to simstr::stringa<span class="tooltiptext code">void ConcatSimToSim(benchmark::State&amp; state) {
    stra s1 = &quot;start &quot;;
    for (auto _: state) {
        for (int i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            stringa str = s1 + i + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">stringa в отличии от std::string,
вмещает в SSO 23 символа вместо 15, поэтому
в конце теста std::string приходится аллоцировать память,
а в stringa весь тест входит в SSO.
Unlike std::string, stringa
holds 23 characters in SSO instead of 15, so
at the end of the std::string test, memory has to be allocated,
while in stringa , the entire test is included in SSO.</span></span></td><td class="benchmarkresult">64.5</td><td class="benchmarkresult">71.6</td><td class="benchmarkresult">66.0</td><td class="benchmarkresult">109</td><td class="benchmarkresult">228</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat stringa and number by e_concat to simstr::stringa<span class="tooltiptext code">void ConcatSimToSimConcat(benchmark::State&amp; state) {
    stra s1 = &quot;start &quot;;
    for (auto _: state) {
        for (int i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            stringa str = e_concat(&quot;&quot;, s1, i, &quot; end&quot;);
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">72.8</td><td class="benchmarkresult">75.7</td><td class="benchmarkresult">76.6</td><td class="benchmarkresult">123</td><td class="benchmarkresult">218</td></tr>
</tbody></table></div><script>bench_sets['Concatenate string + Number + "Literal"'] = {id:'bs1', tests:[
{name:'Concat std::string and number by std to std::string',data:[209,199,268,313,902]},
{name:'Concat std::string and number by StrExpr to std::string',data:[107,94.7,154,210,401]},
{name:'Concat stringa and number by StrExpr to simstr::stringa',data:[64.5,71.6,66.0,109,228]},
{name:'Concat stringa and number by e_concat to simstr::stringa',data:[72.8,75.7,76.6,123,218]}
]}</script>

<div class="benchset" id="bs2"><h4><a id="bs146911715078927772520" href="#bs146911715078927772520">#</a>&nbsp;Concatenate string + Hex Number + &quot;Literal&quot;</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">Concat std::string and format hex number and literal to std::string<span class="tooltiptext code">void ConcatStdToFmtHex(benchmark::State&amp; state) {
    // We use a short string so that the longest result is 15 characters and fits in the std::string SSO buffer.
    std::string s1 = &quot;art &quot;;
    for (auto _: state) {
        for (unsigned i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            // It is not worked for char8_t, char16_t, char32_t :(
            std::string str = s1 + std::format(&quot;{:#x}&quot;, i) + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">682</td><td class="benchmarkresult">643</td><td class="benchmarkresult">741</td><td class="benchmarkresult">1029</td><td class="benchmarkresult">1396</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::format std::string and hex number by literal to std::string<span class="tooltiptext code">void ConcatAllFmtToHex(benchmark::State&amp; state) {
    // We use a short string so that the longest result is 15 characters and fits in the std::string SSO buffer.
    std::string s1 = &quot;art &quot;;
    for (auto _: state) {
        for (unsigned i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            // It is not worked for char8_t, char16_t, char32_t :(
            std::string str = std::format(&quot;{}{:#x} end&quot;, s1, i);
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">862</td><td class="benchmarkresult">926</td><td class="benchmarkresult">1538</td><td class="benchmarkresult">1862</td><td class="benchmarkresult">1628</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat std::string and std::tochars and string to std::string<span class="tooltiptext code">void ConcatStdToCharsHex(benchmark::State&amp; state) {
    // We use a short string so that the longest result is 15 characters and fits in the std::string SSO buffer.
    std::string s1 = &quot;art &quot;;
    for (auto _: state) {
        for (unsigned i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            // it worked only for char :(
            char buf[40];
            size_t len = std::to_chars(buf, buf + std::size(buf), i, 16).ptr - buf;
            std::string str = s1 + &quot;0x&quot; + std::string(buf, len) + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">198</td><td class="benchmarkresult">175</td><td class="benchmarkresult">195</td><td class="benchmarkresult">256</td><td class="benchmarkresult">627</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat std::string and hex number and literal by StrExpr to std::string<span class="tooltiptext code">void ConcatSimToStdHex(benchmark::State&amp; state) {
    // We use a short string so that the longest result is 15 characters and fits in the std::string SSO buffer.
    std::string s1 = &quot;art &quot;;
    for (auto _: state) {
        for (unsigned i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            // Can work for all types of symbols
            std::string str = +s1 + e_hex&lt;HexFlags::Short>(i) + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">132</td><td class="benchmarkresult">122</td><td class="benchmarkresult">80.1</td><td class="benchmarkresult">133</td><td class="benchmarkresult">396</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat stringa and hex number and literal by StrExpr to simstr::stringa<span class="tooltiptext code">void ConcatSimToSimHex(benchmark::State&amp; state) {
    // stringa SSO buffer is 23, but we use a short string to compare under the same conditions
    stra s1 = &quot;art &quot;;
    for (auto _: state) {
        for (unsigned i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            // Can work for all types of symbols
            stringa str = s1 + e_hex&lt;HexFlags::Short>(i) + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">116</td><td class="benchmarkresult">120</td><td class="benchmarkresult">72.4</td><td class="benchmarkresult">109</td><td class="benchmarkresult">209</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat stringa and hex number and literal by e_concat to simstr::stringa<span class="tooltiptext code">void ConcatSimToSimHexC(benchmark::State&amp; state) {
    // stringa SSO buffer is 23, but we use a short string to compare under the same conditions
    stra s1 = &quot;art &quot;;
    for (auto _: state) {
        for (unsigned i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            // Can work for all types of symbols
            stringa str = e_concat(&quot;&quot;, s1, e_hex&lt;HexFlags::Short>(i), &quot; end&quot;);
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">115</td><td class="benchmarkresult">127</td><td class="benchmarkresult">87.1</td><td class="benchmarkresult">102</td><td class="benchmarkresult">221</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Subst stringa and hex number by e_subst literal to simstr::stringa<span class="tooltiptext code">void ConcatSimToSimHexS(benchmark::State&amp; state) {
    // stringa SSO buffer is 23, but we use a short string to compare under the same conditions
    stra s1 = &quot;art &quot;;
    for (auto _: state) {
        for (unsigned i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            stringa str = e_subst(S_FRM(&quot;{}{} end&quot;), s1, e_hex&lt;HexFlags::Short>(i));
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">180</td><td class="benchmarkresult">181</td><td class="benchmarkresult">149</td><td class="benchmarkresult">175</td><td class="benchmarkresult">450</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Subst stringa and hex number by e_vsubst stra to simstr::stringa<span class="tooltiptext code">void ConcatSimToSimHexVS(benchmark::State&amp; state) {
    // stringa SSO buffer is 23, but we use a short string to compare under the same conditions
    stra s1 = &quot;art &quot;;
    for (auto _: state) {
        for (unsigned i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            stringa str = e_vsubst(&quot;{}{} end&quot;_ss, s1, e_hex&lt;HexFlags::Short>(i));
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">315</td><td class="benchmarkresult">279</td><td class="benchmarkresult">263</td><td class="benchmarkresult">346</td><td class="benchmarkresult">740</td></tr>
</tbody></table></div><script>bench_sets['Concatenate string + Hex Number + "Literal"'] = {id:'bs2', tests:[
{name:'Concat std::string and format hex number and literal to std::string',data:[682,643,741,1029,1396]},
{name:'std::format std::string and hex number by literal to std::string',data:[862,926,1538,1862,1628]},
{name:'Concat std::string and std::tochars and string to std::string',data:[198,175,195,256,627]},
{name:'Concat std::string and hex number and literal by StrExpr to std::string',data:[132,122,80.1,133,396]},
{name:'Concat stringa and hex number and literal by StrExpr to simstr::stringa',data:[116,120,72.4,109,209]},
{name:'Concat stringa and hex number and literal by e_concat to simstr::stringa',data:[115,127,87.1,102,221]},
{name:'Subst stringa and hex number by e_subst literal to simstr::stringa',data:[180,181,149,175,450]},
{name:'Subst stringa and hex number by e_vsubst stra to simstr::stringa',data:[315,279,263,346,740]}
]}</script>

<div class="benchset" id="bs3"><h4><a id="bs59672599204338055190" href="#bs59672599204338055190">#</a>&nbsp;Concatenate string + &quot;Literal&quot;</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">Concat std::string by std to std::string<span class="tooltiptext code">void ConcatStdToStdS(benchmark::State&amp; state) {
    std::string s1 = &quot;start &quot;;
    for (auto _: state) {
        for (int i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            std::string str = s1 + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">44.3</td><td class="benchmarkresult">49.6</td><td class="benchmarkresult">40.1</td><td class="benchmarkresult">56.5</td><td class="benchmarkresult">101</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat std::string by StrExpr to std::string<span class="tooltiptext code">void ConcatSimToStdS(benchmark::State&amp; state) {
    std::string s1 = &quot;start &quot;;
    for (auto _: state) {
        for (int i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            std::string str = +s1 + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">34.8</td><td class="benchmarkresult">29.5</td><td class="benchmarkresult">38.9</td><td class="benchmarkresult">83.3</td><td class="benchmarkresult">108</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat stringa by StrExpr to stringa<span class="tooltiptext code">void ConcatSimToSimS(benchmark::State&amp; state) {
    stra s1 = &quot;start &quot;;
    for (auto _: state) {
        for (int i = 1; i &lt;= 100&#39;000; i *= 10) {
            benchmark::DoNotOptimize(s1);
            stringa str = s1 + &quot; end&quot;;
            benchmark::DoNotOptimize(str);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">29.1</td><td class="benchmarkresult">28.0</td><td class="benchmarkresult">29.2</td><td class="benchmarkresult">52.4</td><td class="benchmarkresult">96.7</td></tr>
</tbody></table></div><script>bench_sets['Concatenate string + "Literal"'] = {id:'bs3', tests:[
{name:'Concat std::string by std to std::string',data:[44.3,49.6,40.1,56.5,101]},
{name:'Concat std::string by StrExpr to std::string',data:[34.8,29.5,38.9,83.3,108]},
{name:'Concat stringa by StrExpr to stringa',data:[29.1,28.0,29.2,52.4,96.7]}
]}</script>

<div class="benchset" id="bs4"><h4><a id="bs68116594352702954700" href="#bs68116594352702954700">#</a>&nbsp;Find three concatenated string in string_view</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">Find concat three std::string<span class="tooltiptext code">size_t find_pos_str(std::string_view src, std::string_view name) {
    // before C++26 we can not concatenate string and string_view...
    return src.find(&quot;\n- &quot;s + std::string{name} + &quot; -\n&quot;);
}</span></span></td><td></td><td class="benchmarkresult">114</td><td class="benchmarkresult">138</td><td class="benchmarkresult">214</td><td class="benchmarkresult">218</td><td class="benchmarkresult">187</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Find concat three strexpr<span class="tooltiptext code">size_t find_pos_exp(ssa src, ssa name) {
    return src.find(std::string{&quot;\n- &quot; + name + &quot; -\n&quot;});
}</span></span></td><td></td><td class="benchmarkresult">50.5</td><td class="benchmarkresult">41.0</td><td class="benchmarkresult">115</td><td class="benchmarkresult">119</td><td class="benchmarkresult">107</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Find concat three simstr<span class="tooltiptext code">size_t find_pos_sim(ssa src, ssa name) {
    return src.find(lstringa&lt;200>{&quot;\n- &quot; + name + &quot; -\n&quot;});
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Если результат конкатенации меньше 207 символов,
он собирается в буфере на стеке, без аллокации и деалокации.
If the concatenation result is less than 207 characters,
it is collected in a stack-based buffer, without allocation or deallocation.</span></span></td><td class="benchmarkresult">53.3</td><td class="benchmarkresult">19.8</td><td class="benchmarkresult">29.9</td><td class="benchmarkresult">28.7</td><td class="benchmarkresult">76.4</td></tr>
</tbody></table></div><script>bench_sets['Find three concatenated string in string_view'] = {id:'bs4', tests:[
{name:'Find concat three std::string',data:[114,138,214,218,187]},
{name:'Find concat three strexpr',data:[50.5,41.0,115,119,107]},
{name:'Find concat three simstr',data:[53.3,19.8,29.9,28.7,76.4]}
]}</script>

<div class="benchset" id="bs5"><h4><a id="bs145290966789248325200" href="#bs145290966789248325200">#</a>&nbsp;Build Type Name</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">BuildTypeNameStr 0/0<span class="tooltiptext code">std::string buildTypeNameStr(std::string_view type_name, size_t prec, size_t scale) {
    std::string res{type_name};
    if (prec) {
        res += &quot;(&quot; + std::to_string(prec);
        if (scale) {
            res += &quot;,&quot; + std::to_string(scale);
        }
        res += &quot;)&quot;;
    }
    return res;
}</span></span></td><td></td><td class="benchmarkresult">7.14</td><td class="benchmarkresult">12.1</td><td class="benchmarkresult">8.10</td><td class="benchmarkresult">17.3</td><td class="benchmarkresult">17.3</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">BuildTypeNameExp 0/0<span class="tooltiptext code">std::string buildTypeNameExp(ssa type_name, size_t prec, size_t scale) {
    if (prec) {
        return type_name + &quot;(&quot; + prec + e_if(scale, &quot;,&quot;_ss + scale) + &quot;)&quot;;
    }
    return type_name;
}</span></span></td><td></td><td class="benchmarkresult">6.74</td><td class="benchmarkresult">6.35</td><td class="benchmarkresult">7.52</td><td class="benchmarkresult">14.0</td><td class="benchmarkresult">16.1</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">BuildTypeNameSim 0/0<span class="tooltiptext code">stringa buildTypeNameSim(ssa type_name, size_t prec, size_t scale) {
    if (prec) {
        return type_name + &quot;(&quot; + prec + e_if(scale, &quot;,&quot;_ss + scale) + &quot;)&quot;;
    }
    return type_name;
}</span></span></td><td></td><td class="benchmarkresult">5.10</td><td class="benchmarkresult">5.22</td><td class="benchmarkresult">8.42</td><td class="benchmarkresult">15.9</td><td class="benchmarkresult">16.4</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">BuildTypeNameStr 10/10<span class="tooltiptext code">std::string buildTypeNameStr(std::string_view type_name, size_t prec, size_t scale) {
    std::string res{type_name};
    if (prec) {
        res += &quot;(&quot; + std::to_string(prec);
        if (scale) {
            res += &quot;,&quot; + std::to_string(scale);
        }
        res += &quot;)&quot;;
    }
    return res;
}</span></span></td><td></td><td class="benchmarkresult">56.6</td><td class="benchmarkresult">84.2</td><td class="benchmarkresult">59.1</td><td class="benchmarkresult">80.2</td><td class="benchmarkresult">274</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">BuildTypeNameExp 10/10<span class="tooltiptext code">std::string buildTypeNameExp(ssa type_name, size_t prec, size_t scale) {
    if (prec) {
        return type_name + &quot;(&quot; + prec + e_if(scale, &quot;,&quot;_ss + scale) + &quot;)&quot;;
    }
    return type_name;
}</span></span></td><td></td><td class="benchmarkresult">30.1</td><td class="benchmarkresult">26.9</td><td class="benchmarkresult">36.1</td><td class="benchmarkresult">42.9</td><td class="benchmarkresult">94.7</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">BuildTypeNameSim 10/10<span class="tooltiptext code">stringa buildTypeNameSim(ssa type_name, size_t prec, size_t scale) {
    if (prec) {
        return type_name + &quot;(&quot; + prec + e_if(scale, &quot;,&quot;_ss + scale) + &quot;)&quot;;
    }
    return type_name;
}</span></span></td><td></td><td class="benchmarkresult">22.6</td><td class="benchmarkresult">23.0</td><td class="benchmarkresult">26.5</td><td class="benchmarkresult">36.1</td><td class="benchmarkresult">68.8</td></tr>
</tbody></table></div><script>bench_sets['Build Type Name'] = {id:'bs5', tests:[
{name:'BuildTypeNameStr 0/0',data:[7.14,12.1,8.10,17.3,17.3]},
{name:'BuildTypeNameExp 0/0',data:[6.74,6.35,7.52,14.0,16.1]},
{name:'BuildTypeNameSim 0/0',data:[5.10,5.22,8.42,15.9,16.4]},
{name:'BuildTypeNameStr 10/10',data:[56.6,84.2,59.1,80.2,274]},
{name:'BuildTypeNameExp 10/10',data:[30.1,26.9,36.1,42.9,94.7]},
{name:'BuildTypeNameSim 10/10',data:[22.6,23.0,26.5,36.1,68.8]}
]}</script>

<div class="benchset" id="bs6"><h4><a id="bs54035654251116789780" href="#bs54035654251116789780">#</a>&nbsp;Replace string by copy</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">Concat with replace str<span class="tooltiptext code">std::string make_str_str(std::string_view from, std::string_view pattern, std::string_view repl) {
    auto str_replace = [](std::string_view from, std::string_view pattern, std::string_view repl) {
        std::string result;
        for (size_t offset = 0; ;) {
            size_t pos = from.find(pattern, offset);
            if (pos == std::string::npos) {
                result += from.substr(offset);
                break;
            }
            result += from.substr(offset, pos - offset);
            result += repl;
            offset = pos + pattern.length();
        }
        return result;
    };
    return &quot;&lt;&quot; + str_replace(from, pattern, repl) + &quot;>&quot;;
}</span></span></td><td></td><td class="benchmarkresult">205</td><td class="benchmarkresult">229</td><td class="benchmarkresult">317</td><td class="benchmarkresult">346</td><td class="benchmarkresult">444</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Concat with replace exp<span class="tooltiptext code">std::string make_str_exp(std::string_view from, std::string_view pattern, std::string_view repl) {
    return &quot;&lt;&quot; + e_repl(from, pattern, repl) + &quot;>&quot;;
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">В simstr строковое выражение для замены подстрок
есть "из коробки".
simstr has a string expression for replacing substrings out of the box.</span></span></td><td class="benchmarkresult">143</td><td class="benchmarkresult">131</td><td class="benchmarkresult">210</td><td class="benchmarkresult">225</td><td class="benchmarkresult">252</td></tr>
</tbody></table></div><script>bench_sets['Replace string by copy'] = {id:'bs6', tests:[
{name:'Concat with replace str',data:[205,229,317,346,444]},
{name:'Concat with replace exp',data:[143,131,210,225,252]}
]}</script>

<div class="benchset" id="bs7"><h4><a id="bs77666948964429305550" href="#bs77666948964429305550">#</a>&nbsp;Create Empty Str</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string e;<span class="tooltiptext code">template&lt;typename T>
void CreateEmpty(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Пустые строки, ничего необычного.
Empty lines, nothing unusual.</span></span></td><td class="benchmarkresult">1.10</td><td class="benchmarkresult">1.13</td><td class="benchmarkresult">1.11</td><td class="benchmarkresult">2.84</td><td class="benchmarkresult">2.15</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view e;<span class="tooltiptext code">template&lt;typename T>
void CreateEmpty(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.376</td><td class="benchmarkresult">0.750</td><td class="benchmarkresult">0.362</td><td class="benchmarkresult">1.82</td><td class="benchmarkresult">0.974</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa e;<span class="tooltiptext code">template&lt;typename T>
void CreateEmpty(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.374</td><td class="benchmarkresult">0.181</td><td class="benchmarkresult">0.371</td><td class="benchmarkresult">1.46</td><td class="benchmarkresult">0.939</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa e;<span class="tooltiptext code">template&lt;typename T>
void CreateEmpty(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.740</td><td class="benchmarkresult">0.731</td><td class="benchmarkresult">0.763</td><td class="benchmarkresult">2.19</td><td class="benchmarkresult">2.19</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20> e;<span class="tooltiptext code">template&lt;typename T>
void CreateEmpty(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">1.13</td><td class="benchmarkresult">1.11</td><td class="benchmarkresult">1.12</td><td class="benchmarkresult">2.62</td><td class="benchmarkresult">2.21</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;40> e;<span class="tooltiptext code">template&lt;typename T>
void CreateEmpty(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">1.19</td><td class="benchmarkresult">1.11</td><td class="benchmarkresult">1.12</td><td class="benchmarkresult">2.57</td><td class="benchmarkresult">2.57</td></tr>
</tbody></table></div><script>bench_sets['Create Empty Str'] = {id:'bs7', tests:[
{name:'std::string e;',data:[1.10,1.13,1.11,2.84,2.15]},
{name:'std::string_view e;',data:[0.376,0.750,0.362,1.82,0.974]},
{name:'ssa e;',data:[0.374,0.181,0.371,1.46,0.939]},
{name:'stringa e;',data:[0.740,0.731,0.763,2.19,2.19]},
{name:'lstringa<20> e;',data:[1.13,1.11,1.12,2.62,2.21]},
{name:'lstringa<40> e;',data:[1.19,1.11,1.12,2.57,2.57]}
]}</script>

<div class="benchset" id="bs8"><h4><a id="bs181001525395597238060" href="#bs181001525395597238060">#</a>&nbsp;Create Str from short literal (9 symbols)</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string e      = &quot;Test text&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateShortLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string = TEST_TEXT;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Короткий литерал помещается во внутренний буфер std::string,
время тратится только на копирование 10 байтов.
The short literal is placed in the internal std::string buffer;
time is spent only copying 10 bytes.</span></span></td><td class="benchmarkresult">1.83</td><td class="benchmarkresult">1.87</td><td class="benchmarkresult">1.82</td><td class="benchmarkresult">2.68</td><td class="benchmarkresult">2.34</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view e = &quot;Test text&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateShortLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string = TEST_TEXT;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">И string_view, и ssa - по сути одно и то же:
указатель на текст и его длина.
Both string_view and ssa are essentially the same thing:
a pointer to text and its length.</span></span></td><td class="benchmarkresult">0.738</td><td class="benchmarkresult">0.734</td><td class="benchmarkresult">0.732</td><td class="benchmarkresult">1.84</td><td class="benchmarkresult">1.26</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa e              = &quot;Test text&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateShortLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string = TEST_TEXT;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.368</td><td class="benchmarkresult">0.735</td><td class="benchmarkresult">0.362</td><td class="benchmarkresult">1.83</td><td class="benchmarkresult">0.978</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa e          = &quot;Test text&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateShortLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string = TEST_TEXT;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">stringa при инициализации константным литералом так же
сохраняет только указатель на текст и его длину.
When initialized with a constant literal, stringa also stores
only a pointer to the text and its length.</span></span></td><td class="benchmarkresult">1.12</td><td class="benchmarkresult">1.14</td><td class="benchmarkresult">1.10</td><td class="benchmarkresult">2.83</td><td class="benchmarkresult">2.18</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20> e     = &quot;Test text&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateShortLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string = TEST_TEXT;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Внутреннего буфера хватает для размещения символов,
время уходит только на копирование байтов.
The internal buffer is sufficient to accommodate characters;
time is spent only on copying bytes.</span></span></td><td class="benchmarkresult">1.89</td><td class="benchmarkresult">1.88</td><td class="benchmarkresult">1.88</td><td class="benchmarkresult">2.56</td><td class="benchmarkresult">2.66</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;40> e     = &quot;Test text&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateShortLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string = TEST_TEXT;
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">1.90</td><td class="benchmarkresult">1.83</td><td class="benchmarkresult">1.86</td><td class="benchmarkresult">2.55</td><td class="benchmarkresult">2.67</td></tr>
</tbody></table></div><script>bench_sets['Create Str from short literal (9 symbols)'] = {id:'bs8', tests:[
{name:'std::string e      = "Test text";',data:[1.83,1.87,1.82,2.68,2.34]},
{name:'std::string_view e = "Test text";',data:[0.738,0.734,0.732,1.84,1.26]},
{name:'ssa e              = "Test text";',data:[0.368,0.735,0.362,1.83,0.978]},
{name:'stringa e          = "Test text";',data:[1.12,1.14,1.10,2.83,2.18]},
{name:'lstringa<20> e     = "Test text";',data:[1.89,1.88,1.88,2.56,2.66]},
{name:'lstringa<40> e     = "Test text";',data:[1.90,1.83,1.86,2.55,2.67]}
]}</script>

<div class="benchset" id="bs9"><h4><a id="bs132333183298742730280" href="#bs132333183298742730280">#</a>&nbsp;Create Str from long literal (30 symbols)</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string e      = &quot;123456789012345678901234567890&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateLongLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string{LONG_TEXT};
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Вот тут уже литерал не помещается во внутренний буфер,
возникает аллокация и копирование 30-и байтов.
Но как же отстает аллокация под Windows от Linux'а, 20 vs 70 ns...
Here, the literal doesn't fit into the internal buffer,
and 30 bytes are allocated and copied.
But how much slower is allocation under Windows than under Linux, 20 ns vs. 70 ns...</span></span></td><td class="benchmarkresult">18.7</td><td class="benchmarkresult">18.8</td><td class="benchmarkresult">79.3</td><td class="benchmarkresult">78.1</td><td class="benchmarkresult">15.9</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view e = &quot;123456789012345678901234567890&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateLongLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string{LONG_TEXT};
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">string_view и ssa по прежнему ничего не делают, кроме
запоминания указателя на текст и его размера.
string_view and ssa still do nothing except
remember the pointer to the text and its size.</span></span></td><td class="benchmarkresult">0.741</td><td class="benchmarkresult">0.738</td><td class="benchmarkresult">0.726</td><td class="benchmarkresult">1.83</td><td class="benchmarkresult">1.25</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa e              = &quot;123456789012345678901234567890&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateLongLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string{LONG_TEXT};
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.369</td><td class="benchmarkresult">0.732</td><td class="benchmarkresult">0.364</td><td class="benchmarkresult">1.82</td><td class="benchmarkresult">0.981</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa e          = &quot;123456789012345678901234567890&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateLongLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string{LONG_TEXT};
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">stringa на константных литералах не отстает!
stringa doesn't lag behind on constant literals!</span></span></td><td class="benchmarkresult">1.11</td><td class="benchmarkresult">1.11</td><td class="benchmarkresult">1.11</td><td class="benchmarkresult">2.54</td><td class="benchmarkresult">2.24</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20> e     = &quot;123456789012345678901234567890&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateLongLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string{LONG_TEXT};
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">lstringa<20> может вместить в себя до 23 символов,
Очевидно, что для 30-и символов уже нужна аллокация.
Obviously, 30 characters already require allocation.</span></span></td><td class="benchmarkresult">20.5</td><td class="benchmarkresult">21.2</td><td class="benchmarkresult">75.7</td><td class="benchmarkresult">74.9</td><td class="benchmarkresult">17.2</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;40> e     = &quot;123456789012345678901234567890&quot;;<span class="tooltiptext code">template&lt;typename T>
void CreateLongLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        T empty_string{LONG_TEXT};
        benchmark::DoNotOptimize(empty_string);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">А в lstringa<40> влезает до 47 символов, так что просто
копируется 30 байтов.
And lstringa<40> can hold up to 47 characters, so 30
bytes are simply copied.</span></span></td><td class="benchmarkresult">2.55</td><td class="benchmarkresult">1.85</td><td class="benchmarkresult">2.53</td><td class="benchmarkresult">3.31</td><td class="benchmarkresult">2.99</td></tr>
</tbody></table></div><script>bench_sets['Create Str from long literal (30 symbols)'] = {id:'bs9', tests:[
{name:'std::string e      = "123456789012345678901234567890";',data:[18.7,18.8,79.3,78.1,15.9]},
{name:'std::string_view e = "123456789012345678901234567890";',data:[0.741,0.738,0.726,1.83,1.25]},
{name:'ssa e              = "123456789012345678901234567890";',data:[0.369,0.732,0.364,1.82,0.981]},
{name:'stringa e          = "123456789012345678901234567890";',data:[1.11,1.11,1.11,2.54,2.24]},
{name:'lstringa<20> e     = "123456789012345678901234567890";',data:[20.5,21.2,75.7,74.9,17.2]},
{name:'lstringa<40> e     = "123456789012345678901234567890";',data:[2.55,1.85,2.53,3.31,2.99]}
]}</script>

<div class="benchset" id="bs10"><h4><a id="bs6234433963744178700" href="#bs6234433963744178700">#</a>&nbsp;Create copy of Str with 9 symbols</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string e      = &quot;Test text&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyShortString(benchmark::State&amp; state) {
    T x{TEST_TEXT};
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Строка в пределах SSO, так что просто копирует байты.
The string is within the SSO, so it just copies the bytes.</span></span></td><td class="benchmarkresult">5.14</td><td class="benchmarkresult">4.82</td><td class="benchmarkresult">1.88</td><td class="benchmarkresult">5.75</td><td class="benchmarkresult">2.26</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view e = &quot;Test text&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyShortString(benchmark::State&amp; state) {
    T x{TEST_TEXT};
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.388</td><td class="benchmarkresult">0.381</td><td class="benchmarkresult">0.371</td><td class="benchmarkresult">3.49</td><td class="benchmarkresult">1.25</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa e              = &quot;Test text&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyShortString(benchmark::State&amp; state) {
    T x{TEST_TEXT};
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">ssa и string_view не владеют строкой, копируется
только информация о строке.
ssa and string_view don't own the string; only the
string information is copied.</span></span></td><td class="benchmarkresult">0.367</td><td class="benchmarkresult">0.373</td><td class="benchmarkresult">0.376</td><td class="benchmarkresult">3.51</td><td class="benchmarkresult">1.24</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa e          = &quot;Test text&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyShortString(benchmark::State&amp; state) {
    T x{TEST_TEXT};
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Копирование stringa происходит быстро,
особенно если она инициализирована литералом.
Copying a stringa is fast,
especially if it is initialized with a literal.</span></span></td><td class="benchmarkresult">1.10</td><td class="benchmarkresult">1.30</td><td class="benchmarkresult">1.28</td><td class="benchmarkresult">4.03</td><td class="benchmarkresult">2.58</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20> e     = &quot;Test text&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyShortString(benchmark::State&amp; state) {
    T x{TEST_TEXT};
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">В обоих случаях хватает внутреннего буфера.
In both cases, the internal buffer is sufficient.</span></span></td><td class="benchmarkresult">4.38</td><td class="benchmarkresult">4.61</td><td class="benchmarkresult">5.11</td><td class="benchmarkresult">7.80</td><td class="benchmarkresult">15.2</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;40> e     = &quot;Test text&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyShortString(benchmark::State&amp; state) {
    T x{TEST_TEXT};
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Только копируются байты.
Only bytes are copied.</span></span></td><td class="benchmarkresult">4.52</td><td class="benchmarkresult">4.58</td><td class="benchmarkresult">5.11</td><td class="benchmarkresult">8.53</td><td class="benchmarkresult">14.8</td></tr>
</tbody></table></div><script>bench_sets['Create copy of Str with 9 symbols'] = {id:'bs10', tests:[
{name:'std::string e      = "Test text"; auto c{e};',data:[5.14,4.82,1.88,5.75,2.26]},
{name:'std::string_view e = "Test text"; auto c{e};',data:[0.388,0.381,0.371,3.49,1.25]},
{name:'ssa e              = "Test text"; auto c{e};',data:[0.367,0.373,0.376,3.51,1.24]},
{name:'stringa e          = "Test text"; auto c{e};',data:[1.10,1.30,1.28,4.03,2.58]},
{name:'lstringa<20> e     = "Test text"; auto c{e};',data:[4.38,4.61,5.11,7.80,15.2]},
{name:'lstringa<40> e     = "Test text"; auto c{e};',data:[4.52,4.58,5.11,8.53,14.8]}
]}</script>

<div class="benchset" id="bs11"><h4><a id="bs76384575499199461500" href="#bs76384575499199461500">#</a>&nbsp;Create copy of Str with 30 symbols</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string e      = &quot;123456789012345678901234567890&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyLongString(benchmark::State&amp; state) {
    T x = LONG_TEXT;
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Копирования длинной строки вызывает аллокацию,
SSO уже не хватает. И снова как же отстаёт аллокация под Windows...
Copying a long string causes allocations,
SSO is no longer sufficient. And again, how allocation lags under Windows...</span></span></td><td class="benchmarkresult">18.9</td><td class="benchmarkresult">23.8</td><td class="benchmarkresult">77.2</td><td class="benchmarkresult">78.2</td><td class="benchmarkresult">33.9</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view e = &quot;123456789012345678901234567890&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyLongString(benchmark::State&amp; state) {
    T x = LONG_TEXT;
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.733</td><td class="benchmarkresult">0.742</td><td class="benchmarkresult">0.731</td><td class="benchmarkresult">1.81</td><td class="benchmarkresult">1.25</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa e              = &quot;123456789012345678901234567890&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyLongString(benchmark::State&amp; state) {
    T x = LONG_TEXT;
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
    }
}</span></span></td><td></td><td class="benchmarkresult">0.367</td><td class="benchmarkresult">0.742</td><td class="benchmarkresult">0.364</td><td class="benchmarkresult">1.81</td><td class="benchmarkresult">0.972</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa e          = &quot;123456789012345678901234567890&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyLongString(benchmark::State&amp; state) {
    T x = LONG_TEXT;
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">А вот у stringa копирование литерала не зависит от его длины,
сравни с предыдущим бенчмарком.
But with stringa, literal copying doesn't depend on its length,
compare with the previous benchmark.</span></span></td><td class="benchmarkresult">1.15</td><td class="benchmarkresult">1.11</td><td class="benchmarkresult">1.86</td><td class="benchmarkresult">2.92</td><td class="benchmarkresult">2.22</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20> e     = &quot;123456789012345678901234567890&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyLongString(benchmark::State&amp; state) {
    T x = LONG_TEXT;
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Не влезает, аллокация.
Doesn't fit, allocation.</span></span></td><td class="benchmarkresult">19.9</td><td class="benchmarkresult">20.2</td><td class="benchmarkresult">78.6</td><td class="benchmarkresult">80.9</td><td class="benchmarkresult">16.3</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;40> e     = &quot;123456789012345678901234567890&quot;; auto c{e};<span class="tooltiptext code">template&lt;typename T>
void CopyLongString(benchmark::State&amp; state) {
    T x = LONG_TEXT;
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Уложили во внутренний буфер.
Placed in the internal buffer.</span></span></td><td class="benchmarkresult">4.50</td><td class="benchmarkresult">4.82</td><td class="benchmarkresult">4.78</td><td class="benchmarkresult">6.60</td><td class="benchmarkresult">14.0</td></tr>
</tbody></table></div><script>bench_sets['Create copy of Str with 30 symbols'] = {id:'bs11', tests:[
{name:'std::string e      = "123456789012345678901234567890"; auto c{e};',data:[18.9,23.8,77.2,78.2,33.9]},
{name:'std::string_view e = "123456789012345678901234567890"; auto c{e};',data:[0.733,0.742,0.731,1.81,1.25]},
{name:'ssa e              = "123456789012345678901234567890"; auto c{e};',data:[0.367,0.742,0.364,1.81,0.972]},
{name:'stringa e          = "123456789012345678901234567890"; auto c{e};',data:[1.15,1.11,1.86,2.92,2.22]},
{name:'lstringa<20> e     = "123456789012345678901234567890"; auto c{e};',data:[19.9,20.2,78.6,80.9,16.3]},
{name:'lstringa<40> e     = "123456789012345678901234567890"; auto c{e};',data:[4.50,4.82,4.78,6.60,14.0]}
]}</script>

<div class="benchset" id="bs12"><h4><a id="bs21623892135774528620" href="#bs21623892135774528620">#</a>&nbsp;Find 9 symbols text in end of 99 symbols text</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string::find;<span class="tooltiptext code">template&lt;typename T>
void Find(benchmark::State&amp; state) {
    T x{LONG_TEXT LONG_TEXT LONG_TEXT TEST_TEXT};
    for (auto _: state) {
        int i = (int)x.find(TEST_TEXT);
    #ifdef CHECK_RESULT
        if (i != 90) {
            state.SkipWithError(&quot;not find?&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(i);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Здесь "победила дружба", у всех типов по колонке примерно одинаково.
Однако, Windows и Linux явно в разных весовых категориях.
Here, "friendship wins," with all types scoring roughly equally.
However, Windows and Linux are clearly in different weight classes.</span></span></td><td class="benchmarkresult">6.71</td><td class="benchmarkresult">6.82</td><td class="benchmarkresult">38.3</td><td class="benchmarkresult">41.9</td><td class="benchmarkresult">45.3</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view::find;<span class="tooltiptext code">template&lt;typename T>
void Find(benchmark::State&amp; state) {
    T x{LONG_TEXT LONG_TEXT LONG_TEXT TEST_TEXT};
    for (auto _: state) {
        int i = (int)x.find(TEST_TEXT);
    #ifdef CHECK_RESULT
        if (i != 90) {
            state.SkipWithError(&quot;not find?&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(i);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">7.24</td><td class="benchmarkresult">6.76</td><td class="benchmarkresult">38.8</td><td class="benchmarkresult">39.7</td><td class="benchmarkresult">49.9</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa::find;<span class="tooltiptext code">template&lt;typename T>
void Find(benchmark::State&amp; state) {
    T x{LONG_TEXT LONG_TEXT LONG_TEXT TEST_TEXT};
    for (auto _: state) {
        int i = (int)x.find(TEST_TEXT);
    #ifdef CHECK_RESULT
        if (i != 90) {
            state.SkipWithError(&quot;not find?&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(i);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">6.72</td><td class="benchmarkresult">6.29</td><td class="benchmarkresult">17.4</td><td class="benchmarkresult">20.6</td><td class="benchmarkresult">49.3</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa::find;<span class="tooltiptext code">template&lt;typename T>
void Find(benchmark::State&amp; state) {
    T x{LONG_TEXT LONG_TEXT LONG_TEXT TEST_TEXT};
    for (auto _: state) {
        int i = (int)x.find(TEST_TEXT);
    #ifdef CHECK_RESULT
        if (i != 90) {
            state.SkipWithError(&quot;not find?&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(i);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">7.59</td><td class="benchmarkresult">6.82</td><td class="benchmarkresult">18.3</td><td class="benchmarkresult">28.7</td><td class="benchmarkresult">51.1</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20>::find;<span class="tooltiptext code">template&lt;typename T>
void Find(benchmark::State&amp; state) {
    T x{LONG_TEXT LONG_TEXT LONG_TEXT TEST_TEXT};
    for (auto _: state) {
        int i = (int)x.find(TEST_TEXT);
    #ifdef CHECK_RESULT
        if (i != 90) {
            state.SkipWithError(&quot;not find?&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(i);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">6.27</td><td class="benchmarkresult">7.09</td><td class="benchmarkresult">17.5</td><td class="benchmarkresult">20.7</td><td class="benchmarkresult">43.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;40>::find;<span class="tooltiptext code">template&lt;typename T>
void Find(benchmark::State&amp; state) {
    T x{LONG_TEXT LONG_TEXT LONG_TEXT TEST_TEXT};
    for (auto _: state) {
        int i = (int)x.find(TEST_TEXT);
    #ifdef CHECK_RESULT
        if (i != 90) {
            state.SkipWithError(&quot;not find?&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(i);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">6.32</td><td class="benchmarkresult">6.43</td><td class="benchmarkresult">17.8</td><td class="benchmarkresult">21.9</td><td class="benchmarkresult">43.8</td></tr>
</tbody></table></div><script>bench_sets['Find 9 symbols text in end of 99 symbols text'] = {id:'bs12', tests:[
{name:'std::string::find;',data:[6.71,6.82,38.3,41.9,45.3]},
{name:'std::string_view::find;',data:[7.24,6.76,38.8,39.7,49.9]},
{name:'ssa::find;',data:[6.72,6.29,17.4,20.6,49.3]},
{name:'stringa::find;',data:[7.59,6.82,18.3,28.7,51.1]},
{name:'lstringa<20>::find;',data:[6.27,7.09,17.5,20.7,43.8]},
{name:'lstringa<40>::find;',data:[6.32,6.43,17.8,21.9,43.8]}
]}</script>

<div class="benchset" id="bs13"><h4><a id="bs170792414351801782640" href="#bs170792414351801782640">#</a>&nbsp;Copy not literal Str with N symbols</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/15<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">4.85</td><td class="benchmarkresult">4.81</td><td class="benchmarkresult">1.92</td><td class="benchmarkresult">5.06</td><td class="benchmarkresult">34.6</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/16<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Явно виден скачок, где заканчивается SSO и начинается аллокация.
Обратите внимание, что WASM - 32-битный, и там размер
SSO у std::string меньше, насколько я помню, 11 символов + 0.
The jump where SSO ends and allocation begins is clearly visible.
Note that WASM is 32-bit, and the size of the SSO for std::string is
smaller, as far as I remember: 11 characters + 0.</span></span></td><td class="benchmarkresult">22.2</td><td class="benchmarkresult">23.2</td><td class="benchmarkresult">79.1</td><td class="benchmarkresult">84.4</td><td class="benchmarkresult">34.9</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/23<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Дальше просто добавляется время на копирование байтов.
Then the time for copying bytes is simply added.</span></span></td><td class="benchmarkresult">22.2</td><td class="benchmarkresult">23.2</td><td class="benchmarkresult">80.3</td><td class="benchmarkresult">89.2</td><td class="benchmarkresult">36.1</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/24<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">24.0</td><td class="benchmarkresult">24.7</td><td class="benchmarkresult">79.5</td><td class="benchmarkresult">87.8</td><td class="benchmarkresult">34.4</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/32<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">23.4</td><td class="benchmarkresult">22.7</td><td class="benchmarkresult">81.8</td><td class="benchmarkresult">88.9</td><td class="benchmarkresult">37.9</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/64<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">22.0</td><td class="benchmarkresult">22.5</td><td class="benchmarkresult">81.2</td><td class="benchmarkresult">86.8</td><td class="benchmarkresult">37.7</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/128<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">23.5</td><td class="benchmarkresult">24.4</td><td class="benchmarkresult">84.4</td><td class="benchmarkresult">90.9</td><td class="benchmarkresult">39.1</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/256<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">28.6</td><td class="benchmarkresult">28.2</td><td class="benchmarkresult">87.2</td><td class="benchmarkresult">97.0</td><td class="benchmarkresult">59.2</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/512<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">28.7</td><td class="benchmarkresult">28.6</td><td class="benchmarkresult">84.9</td><td class="benchmarkresult">95.8</td><td class="benchmarkresult">55.7</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/1024<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">35.9</td><td class="benchmarkresult">33.8</td><td class="benchmarkresult">96.5</td><td class="benchmarkresult">101</td><td class="benchmarkresult">54.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/2048<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">119</td><td class="benchmarkresult">121</td><td class="benchmarkresult">129</td><td class="benchmarkresult">128</td><td class="benchmarkresult">78.0</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string copy{str_with_len_N};/4096<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Чем длиннее строка, тем дольше создаётся копия.
The longer the string, the longer it takes to create a copy.</span></span></td><td class="benchmarkresult">150</td><td class="benchmarkresult">164</td><td class="benchmarkresult">172</td><td class="benchmarkresult">179</td><td class="benchmarkresult">112</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/15<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Здесь stringa инициализируется не литералом,
а значит, должна сама хранить символы.
Here, stringa is not initialized with a literal,
meaning it must store characters itself.</span></span></td><td class="benchmarkresult">1.10</td><td class="benchmarkresult">1.11</td><td class="benchmarkresult">1.28</td><td class="benchmarkresult">3.98</td><td class="benchmarkresult">2.56</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/16<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Под WASM SSO у stringa составляет 15 символов. Кроме того,
собиралось без поддержки потоков, поэтому атомарный
инкремент заменён на обычный, судя по времени.
Under WASM, stringa has a 15-character SSO. Furthermore,
it was built without thread support, so the atomic
increment was replaced with a regular one, judging by the time.</span></span></td><td class="benchmarkresult">1.10</td><td class="benchmarkresult">1.12</td><td class="benchmarkresult">1.28</td><td class="benchmarkresult">3.99</td><td class="benchmarkresult">4.87</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/23<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">SSO в stringa до 23 символов, и даже 23
копируются быстрее, чем 15 в std::string.
SSO in stringa is up to 23 characters, and even 23
copies faster than 15 in std::string.</span></span></td><td class="benchmarkresult">1.16</td><td class="benchmarkresult">1.12</td><td class="benchmarkresult">1.29</td><td class="benchmarkresult">3.98</td><td class="benchmarkresult">4.85</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/24<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Всё, не влезаем в SSO, а значит, используем shared буфер.
Добавляется время на атомарный инкремент счётчика.
That's it, we're not using SSO, so we're using a shared buffer.
Time is added for the atomic counter increment.</span></span></td><td class="benchmarkresult">16.0</td><td class="benchmarkresult">16.4</td><td class="benchmarkresult">15.9</td><td class="benchmarkresult">18.3</td><td class="benchmarkresult">4.91</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/32<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">16.0</td><td class="benchmarkresult">16.1</td><td class="benchmarkresult">16.0</td><td class="benchmarkresult">18.3</td><td class="benchmarkresult">4.87</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/64<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">16.3</td><td class="benchmarkresult">16.1</td><td class="benchmarkresult">16.7</td><td class="benchmarkresult">18.4</td><td class="benchmarkresult">4.81</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/128<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">16.3</td><td class="benchmarkresult">16.1</td><td class="benchmarkresult">15.8</td><td class="benchmarkresult">18.3</td><td class="benchmarkresult">4.84</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/256<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">16.0</td><td class="benchmarkresult">16.3</td><td class="benchmarkresult">15.8</td><td class="benchmarkresult">18.4</td><td class="benchmarkresult">4.87</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/512<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">16.0</td><td class="benchmarkresult">16.4</td><td class="benchmarkresult">15.8</td><td class="benchmarkresult">18.4</td><td class="benchmarkresult">4.82</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/1024<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">16.0</td><td class="benchmarkresult">16.3</td><td class="benchmarkresult">15.8</td><td class="benchmarkresult">18.3</td><td class="benchmarkresult">4.98</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/2048<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">16.1</td><td class="benchmarkresult">16.1</td><td class="benchmarkresult">15.8</td><td class="benchmarkresult">18.3</td><td class="benchmarkresult">4.90</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa copy{str_with_len_N};/4096<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">И как видно, кроме инкремента нет накладных расходов,
время копирования не зависит от длины строки.
And as you can see, there are no overhead costs other than the
increment; copying time does not depend on the string length.</span></span></td><td class="benchmarkresult">16.2</td><td class="benchmarkresult">16.1</td><td class="benchmarkresult">15.8</td><td class="benchmarkresult">18.3</td><td class="benchmarkresult">4.84</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/15<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">lstringa<16> использует SSO до 23 символов.
А в WASM 32-битная архитектура, SSO до 19 символов.
lstringa<16> uses SSO up to 23 characters.
WASM has a 32-bit architecture, so SSO is up to 19 characters.</span></span></td><td class="benchmarkresult">4.49</td><td class="benchmarkresult">4.55</td><td class="benchmarkresult">4.78</td><td class="benchmarkresult">7.39</td><td class="benchmarkresult">14.3</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/16<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">4.67</td><td class="benchmarkresult">4.50</td><td class="benchmarkresult">5.32</td><td class="benchmarkresult">7.62</td><td class="benchmarkresult">15.0</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/23<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">4.62</td><td class="benchmarkresult">4.44</td><td class="benchmarkresult">5.12</td><td class="benchmarkresult">7.32</td><td class="benchmarkresult">28.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/24<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">И после начинает вести себя при копировании, как std::string.
And then it starts to behave like std::string when copied.</span></span></td><td class="benchmarkresult">23.8</td><td class="benchmarkresult">24.5</td><td class="benchmarkresult">79.7</td><td class="benchmarkresult">81.1</td><td class="benchmarkresult">29.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/32<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">23.5</td><td class="benchmarkresult">24.4</td><td class="benchmarkresult">81.5</td><td class="benchmarkresult">83.8</td><td class="benchmarkresult">31.9</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/64<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">25.2</td><td class="benchmarkresult">26.5</td><td class="benchmarkresult">78.6</td><td class="benchmarkresult">83.4</td><td class="benchmarkresult">31.3</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/128<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">25.2</td><td class="benchmarkresult">26.6</td><td class="benchmarkresult">82.0</td><td class="benchmarkresult">87.0</td><td class="benchmarkresult">32.5</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/256<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">27.8</td><td class="benchmarkresult">29.7</td><td class="benchmarkresult">83.4</td><td class="benchmarkresult">88.8</td><td class="benchmarkresult">54.6</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/512<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">30.4</td><td class="benchmarkresult">30.8</td><td class="benchmarkresult">85.2</td><td class="benchmarkresult">90.7</td><td class="benchmarkresult">51.6</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/1024<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">95.7</td><td class="benchmarkresult">93.8</td><td class="benchmarkresult">96.3</td><td class="benchmarkresult">96.3</td><td class="benchmarkresult">51.0</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/2048<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">122</td><td class="benchmarkresult">124</td><td class="benchmarkresult">124</td><td class="benchmarkresult">128</td><td class="benchmarkresult">74.1</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> copy{str_with_len_N};/4096<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">128</td><td class="benchmarkresult">128</td><td class="benchmarkresult">181</td><td class="benchmarkresult">187</td><td class="benchmarkresult">110</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/15<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">4.94</td><td class="benchmarkresult">5.79</td><td class="benchmarkresult">5.22</td><td class="benchmarkresult">8.92</td><td class="benchmarkresult">14.4</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/16<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">5.13</td><td class="benchmarkresult">6.04</td><td class="benchmarkresult">5.27</td><td class="benchmarkresult">8.52</td><td class="benchmarkresult">14.2</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/23<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">4.86</td><td class="benchmarkresult">5.66</td><td class="benchmarkresult">5.42</td><td class="benchmarkresult">8.80</td><td class="benchmarkresult">14.0</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/24<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">4.91</td><td class="benchmarkresult">5.74</td><td class="benchmarkresult">5.13</td><td class="benchmarkresult">8.46</td><td class="benchmarkresult">14.2</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/32<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">4.56</td><td class="benchmarkresult">5.34</td><td class="benchmarkresult">7.99</td><td class="benchmarkresult">11.4</td><td class="benchmarkresult">17.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/64<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">5.95</td><td class="benchmarkresult">6.83</td><td class="benchmarkresult">8.09</td><td class="benchmarkresult">11.4</td><td class="benchmarkresult">17.4</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/128<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">6.86</td><td class="benchmarkresult">6.97</td><td class="benchmarkresult">8.40</td><td class="benchmarkresult">11.9</td><td class="benchmarkresult">17.6</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/256<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">17.1</td><td class="benchmarkresult">7.83</td><td class="benchmarkresult">9.69</td><td class="benchmarkresult">12.8</td><td class="benchmarkresult">19.4</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/512<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Даже 512 символов копируются быстрее, чем
одна аллокация или атомарный инкремент.
Even 512 characters are copied faster than a single
allocation or atomic increment.</span></span></td><td class="benchmarkresult">10.3</td><td class="benchmarkresult">10.6</td><td class="benchmarkresult">11.4</td><td class="benchmarkresult">14.3</td><td class="benchmarkresult">21.6</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/1024<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">А дальше уже как у всех.
And then it's like everyone else.</span></span></td><td class="benchmarkresult">95.0</td><td class="benchmarkresult">94.8</td><td class="benchmarkresult">98.1</td><td class="benchmarkresult">94.9</td><td class="benchmarkresult">52.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/2048<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">113</td><td class="benchmarkresult">114</td><td class="benchmarkresult">129</td><td class="benchmarkresult">132</td><td class="benchmarkresult">74.7</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> copy{str_with_len_N};/4096<span class="tooltiptext code">template&lt;typename T>
void CopyDynString(benchmark::State&amp; state) {
    T x(state.range(0), &#39;a&#39;);
    for (auto _: state) {
        T copy{x};
        benchmark::DoNotOptimize(copy);
        benchmark::DoNotOptimize(x);
    }
}</span></span></td><td></td><td class="benchmarkresult">126</td><td class="benchmarkresult">128</td><td class="benchmarkresult">185</td><td class="benchmarkresult">189</td><td class="benchmarkresult">111</td></tr>
</tbody></table></div><script>bench_sets['Copy not literal Str with N symbols'] = {id:'bs13', tests:[
{name:'std::string copy{str_with_len_N};/15',data:[4.85,4.81,1.92,5.06,34.6]},
{name:'std::string copy{str_with_len_N};/16',data:[22.2,23.2,79.1,84.4,34.9]},
{name:'std::string copy{str_with_len_N};/23',data:[22.2,23.2,80.3,89.2,36.1]},
{name:'std::string copy{str_with_len_N};/24',data:[24.0,24.7,79.5,87.8,34.4]},
{name:'std::string copy{str_with_len_N};/32',data:[23.4,22.7,81.8,88.9,37.9]},
{name:'std::string copy{str_with_len_N};/64',data:[22.0,22.5,81.2,86.8,37.7]},
{name:'std::string copy{str_with_len_N};/128',data:[23.5,24.4,84.4,90.9,39.1]},
{name:'std::string copy{str_with_len_N};/256',data:[28.6,28.2,87.2,97.0,59.2]},
{name:'std::string copy{str_with_len_N};/512',data:[28.7,28.6,84.9,95.8,55.7]},
{name:'std::string copy{str_with_len_N};/1024',data:[35.9,33.8,96.5,101,54.8]},
{name:'std::string copy{str_with_len_N};/2048',data:[119,121,129,128,78.0]},
{name:'std::string copy{str_with_len_N};/4096',data:[150,164,172,179,112]},
{name:'stringa copy{str_with_len_N};/15',data:[1.10,1.11,1.28,3.98,2.56]},
{name:'stringa copy{str_with_len_N};/16',data:[1.10,1.12,1.28,3.99,4.87]},
{name:'stringa copy{str_with_len_N};/23',data:[1.16,1.12,1.29,3.98,4.85]},
{name:'stringa copy{str_with_len_N};/24',data:[16.0,16.4,15.9,18.3,4.91]},
{name:'stringa copy{str_with_len_N};/32',data:[16.0,16.1,16.0,18.3,4.87]},
{name:'stringa copy{str_with_len_N};/64',data:[16.3,16.1,16.7,18.4,4.81]},
{name:'stringa copy{str_with_len_N};/128',data:[16.3,16.1,15.8,18.3,4.84]},
{name:'stringa copy{str_with_len_N};/256',data:[16.0,16.3,15.8,18.4,4.87]},
{name:'stringa copy{str_with_len_N};/512',data:[16.0,16.4,15.8,18.4,4.82]},
{name:'stringa copy{str_with_len_N};/1024',data:[16.0,16.3,15.8,18.3,4.98]},
{name:'stringa copy{str_with_len_N};/2048',data:[16.1,16.1,15.8,18.3,4.90]},
{name:'stringa copy{str_with_len_N};/4096',data:[16.2,16.1,15.8,18.3,4.84]},
{name:'lstringa<16> copy{str_with_len_N};/15',data:[4.49,4.55,4.78,7.39,14.3]},
{name:'lstringa<16> copy{str_with_len_N};/16',data:[4.67,4.50,5.32,7.62,15.0]},
{name:'lstringa<16> copy{str_with_len_N};/23',data:[4.62,4.44,5.12,7.32,28.8]},
{name:'lstringa<16> copy{str_with_len_N};/24',data:[23.8,24.5,79.7,81.1,29.8]},
{name:'lstringa<16> copy{str_with_len_N};/32',data:[23.5,24.4,81.5,83.8,31.9]},
{name:'lstringa<16> copy{str_with_len_N};/64',data:[25.2,26.5,78.6,83.4,31.3]},
{name:'lstringa<16> copy{str_with_len_N};/128',data:[25.2,26.6,82.0,87.0,32.5]},
{name:'lstringa<16> copy{str_with_len_N};/256',data:[27.8,29.7,83.4,88.8,54.6]},
{name:'lstringa<16> copy{str_with_len_N};/512',data:[30.4,30.8,85.2,90.7,51.6]},
{name:'lstringa<16> copy{str_with_len_N};/1024',data:[95.7,93.8,96.3,96.3,51.0]},
{name:'lstringa<16> copy{str_with_len_N};/2048',data:[122,124,124,128,74.1]},
{name:'lstringa<16> copy{str_with_len_N};/4096',data:[128,128,181,187,110]},
{name:'lstringa<512> copy{str_with_len_N};/15',data:[4.94,5.79,5.22,8.92,14.4]},
{name:'lstringa<512> copy{str_with_len_N};/16',data:[5.13,6.04,5.27,8.52,14.2]},
{name:'lstringa<512> copy{str_with_len_N};/23',data:[4.86,5.66,5.42,8.80,14.0]},
{name:'lstringa<512> copy{str_with_len_N};/24',data:[4.91,5.74,5.13,8.46,14.2]},
{name:'lstringa<512> copy{str_with_len_N};/32',data:[4.56,5.34,7.99,11.4,17.8]},
{name:'lstringa<512> copy{str_with_len_N};/64',data:[5.95,6.83,8.09,11.4,17.4]},
{name:'lstringa<512> copy{str_with_len_N};/128',data:[6.86,6.97,8.40,11.9,17.6]},
{name:'lstringa<512> copy{str_with_len_N};/256',data:[17.1,7.83,9.69,12.8,19.4]},
{name:'lstringa<512> copy{str_with_len_N};/512',data:[10.3,10.6,11.4,14.3,21.6]},
{name:'lstringa<512> copy{str_with_len_N};/1024',data:[95.0,94.8,98.1,94.9,52.8]},
{name:'lstringa<512> copy{str_with_len_N};/2048',data:[113,114,129,132,74.7]},
{name:'lstringa<512> copy{str_with_len_N};/4096',data:[126,128,185,189,111]}
]}</script>

<div class="benchset" id="bs14"><h4><a id="bs94756718925776995960" href="#bs94756718925776995960">#</a>&nbsp;Convert to int &#39;1234567&#39;</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string s = &quot;123456789&quot;; int res = std::strtol(s.c_str(), 0, 10);<span class="tooltiptext code">void ToIntStr10(benchmark::State&amp; state, const std::string&amp; s, int c) {
    for (auto _: state) {
        int res = std::strtol(s.c_str(), nullptr, 10);
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">В simstr для конвертации в число достаточно куска строки,
нет нужды в null терминированности. Ближайший аналог такого
поведения "std::from_chars", но он к сожалению очень ограничен
по возможностям. Здесь я попытался произвести тесты, близкие по
логике к работе std::from_chars
In simstr, a string fragment is sufficient for conversion to a number;
there's no need for null termination. The closest analog to this behavior
is "std::from_chars," but unfortunately, it is very limited in its capabilities.
Here, I attempted to run tests that are similar in logic to std::from_chars.</span></span></td><td class="benchmarkresult">26.9</td><td class="benchmarkresult">27.0</td><td class="benchmarkresult">30.7</td><td class="benchmarkresult">32.0</td><td class="benchmarkresult">70.3</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view s = &quot;123456789&quot;; std::from_chars(s.data(), s.data() + s.size(), res, 10);<span class="tooltiptext code">void ToIntFromChars10(benchmark::State&amp; state, const std::string_view&amp; s, int c) {
    for (auto _: state) {
        int res = 0;
        std::from_chars(s.data(), s.data() + s.size(), res, 10);
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">from_chars требует точного указания основания счисления,
не допускает знаков плюс, пробелов, префиксов 0x и т.п.
from_chars requires an exact radix specification and does not allow plus
signs, spaces, 0x prefixes, etc.</span></span></td><td class="benchmarkresult">14.8</td><td class="benchmarkresult">12.1</td><td class="benchmarkresult">13.5</td><td class="benchmarkresult">13.4</td><td class="benchmarkresult">27.4</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa s = &quot;123456789&quot;; int res = s.to_int&lt;int, true, 10, false><span class="tooltiptext code">template&lt;typename T>
void ToIntSimStr10(benchmark::State&amp; state, T t, int c) {
    for (auto _: state) {
        int res = t. template to_int&lt;int, true, 10, false, false>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Здесь для to_int заданы такие же ограничения - проверять переполнение,
десятичная система, без лидирующих пробелов и знака плюс
Here, to_int has the same restrictions: check for overflow,
decimal system, no leading spaces, and no plus sign.</span></span></td><td class="benchmarkresult">12.9</td><td class="benchmarkresult">8.11</td><td class="benchmarkresult">14.1</td><td class="benchmarkresult">15.9</td><td class="benchmarkresult">18.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa s = &quot;123456789&quot;; int res = s.to_int&lt;int, true, 10, false><span class="tooltiptext code">template&lt;typename T>
void ToIntSimStr10(benchmark::State&amp; state, T t, int c) {
    for (auto _: state) {
        int res = t. template to_int&lt;int, true, 10, false, false>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">12.9</td><td class="benchmarkresult">8.22</td><td class="benchmarkresult">13.8</td><td class="benchmarkresult">15.0</td><td class="benchmarkresult">16.9</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20> s = &quot;123456789&quot;; int res = s.to_int&lt;int, true, 10, false><span class="tooltiptext code">template&lt;typename T>
void ToIntSimStr10(benchmark::State&amp; state, T t, int c) {
    for (auto _: state) {
        int res = t. template to_int&lt;int, true, 10, false, false>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">12.3</td><td class="benchmarkresult">8.07</td><td class="benchmarkresult">14.8</td><td class="benchmarkresult">15.9</td><td class="benchmarkresult">16.7</td></tr>
</tbody></table></div><script>bench_sets['Convert to int \'1234567\''] = {id:'bs14', tests:[
{name:'std::string s = "123456789"; int res = std::strtol(s.c_str(), 0, 10);',data:[26.9,27.0,30.7,32.0,70.3]},
{name:'std::string_view s = "123456789"; std::from_chars(s.data(), s.data() + s.size(), res, 10);',data:[14.8,12.1,13.5,13.4,27.4]},
{name:'stringa s = "123456789"; int res = s.to_int<int, true, 10, false>',data:[12.9,8.11,14.1,15.9,18.8]},
{name:'ssa s = "123456789"; int res = s.to_int<int, true, 10, false>',data:[12.9,8.22,13.8,15.0,16.9]},
{name:'lstringa<20> s = "123456789"; int res = s.to_int<int, true, 10, false>',data:[12.3,8.07,14.8,15.9,16.7]}
]}</script>

<div class="benchset" id="bs15"><h4><a id="bs182426078870126042750" href="#bs182426078870126042750">#</a>&nbsp;Convert to unsigned &#39;abcDef&#39;</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string s = &quot;abcDef&quot;; int res = std::strtol(s.c_str(), 0, 16);<span class="tooltiptext code">void ToIntStr16(benchmark::State&amp; state, const std::string&amp; s, int c) {
    for (auto _: state) {
        int res = std::strtol(s.c_str(), nullptr, 16);
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Всё то же, только для 16ричной системы
Everything is the same, only for the hexadecimal system</span></span></td><td class="benchmarkresult">23.5</td><td class="benchmarkresult">23.2</td><td class="benchmarkresult">33.2</td><td class="benchmarkresult">35.7</td><td class="benchmarkresult">54.8</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view s = &quot;abcDef&quot;; std::from_chars(s.data(), s.data() + s.size(), res, 16);<span class="tooltiptext code">void ToIntFromChars16(benchmark::State&amp; state, const std::string_view&amp; s, int c) {
    for (auto _: state) {
        int res = 0;
        std::from_chars(s.data(), s.data() + s.size(), res, 16);
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
    }
}</span></span></td><td></td><td class="benchmarkresult">9.63</td><td class="benchmarkresult">10.5</td><td class="benchmarkresult">8.21</td><td class="benchmarkresult">12.5</td><td class="benchmarkresult">28.7</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa s = &quot;abcDef&quot;; int res = s.to_int&lt;int, true, 16, false><span class="tooltiptext code">template&lt;typename T>
void ToIntSimStr16(benchmark::State&amp; state, T t, int c) {
    for (auto _: state) {
        int res = t. template to_int&lt;int, true, 16, false, false>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">12.6</td><td class="benchmarkresult">8.08</td><td class="benchmarkresult">12.5</td><td class="benchmarkresult">12.8</td><td class="benchmarkresult">17.4</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa s = &quot;abcDef&quot;; int res = s.to_int&lt;int, true, 16, false><span class="tooltiptext code">template&lt;typename T>
void ToIntSimStr16(benchmark::State&amp; state, T t, int c) {
    for (auto _: state) {
        int res = t. template to_int&lt;int, true, 16, false, false>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">12.6</td><td class="benchmarkresult">8.13</td><td class="benchmarkresult">12.0</td><td class="benchmarkresult">12.8</td><td class="benchmarkresult">16.0</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;20> s = &quot;abcDef&quot;; int res = s.to_int&lt;int, true, 16, false><span class="tooltiptext code">template&lt;typename T>
void ToIntSimStr16(benchmark::State&amp; state, T t, int c) {
    for (auto _: state) {
        int res = t. template to_int&lt;int, true, 16, false, false>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">12.5</td><td class="benchmarkresult">7.77</td><td class="benchmarkresult">12.1</td><td class="benchmarkresult">12.8</td><td class="benchmarkresult">16.2</td></tr>
</tbody></table></div><script>bench_sets['Convert to unsigned \'abcDef\''] = {id:'bs15', tests:[
{name:'std::string s = "abcDef"; int res = std::strtol(s.c_str(), 0, 16);',data:[23.5,23.2,33.2,35.7,54.8]},
{name:'std::string_view s = "abcDef"; std::from_chars(s.data(), s.data() + s.size(), res, 16);',data:[9.63,10.5,8.21,12.5,28.7]},
{name:'stringa s = "abcDef"; int res = s.to_int<int, true, 16, false>',data:[12.6,8.08,12.5,12.8,17.4]},
{name:'ssa s = "abcDef"; int res = s.to_int<int, true, 16, false>',data:[12.6,8.13,12.0,12.8,16.0]},
{name:'lstringa<20> s = "abcDef"; int res = s.to_int<int, true, 16, false>',data:[12.5,7.77,12.1,12.8,16.2]}
]}</script>

<div class="benchset" id="bs16"><h4><a id="bs52606100125109966680" href="#bs52606100125109966680">#</a>&nbsp;Convert to int &#39;    1234567&#39;</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string s = &quot;    123456789&quot;; int res = std::strtol(s.c_str(), 0, 0);<span class="tooltiptext code">void ToIntStr0(benchmark::State&amp; state, const std::string&amp; s, int c) {
    for (auto _: state) {
        int res = std::strtol(s.c_str(), nullptr, 0);
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">А здесь уже парсинг произвольного числа.
And here we have parsing of an arbitrary number.</span></span></td><td class="benchmarkresult">28.5</td><td class="benchmarkresult">28.0</td><td class="benchmarkresult">43.5</td><td class="benchmarkresult">45.7</td><td class="benchmarkresult">77.9</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa s = &quot;    123456789&quot;; int res = s.to_int&lt;int>; // Check overflow<span class="tooltiptext code">template&lt;typename T>
void ToIntSimStr0(benchmark::State&amp; state, T t, int c) {
    for (auto _: state) {
        int res = t. template to_int&lt;int>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">19.6</td><td class="benchmarkresult">14.8</td><td class="benchmarkresult">18.8</td><td class="benchmarkresult">22.1</td><td class="benchmarkresult">24.1</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa s = &quot;    123456789&quot;; int res = s.to_int&lt;int, false>; // No check overflow<span class="tooltiptext code">void ToIntNoOverflow(benchmark::State&amp; state, ssa t, int c) {
    for (auto _: state) {
        int res = t.to_int&lt;int, false>().value;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">15.2</td><td class="benchmarkresult">13.7</td><td class="benchmarkresult">15.4</td><td class="benchmarkresult">16.0</td><td class="benchmarkresult">23.2</td></tr>
</tbody></table></div><script>bench_sets['Convert to int \'    1234567\''] = {id:'bs16', tests:[
{name:'std::string s = "    123456789"; int res = std::strtol(s.c_str(), 0, 0);',data:[28.5,28.0,43.5,45.7,77.9]},
{name:'stringa s = "    123456789"; int res = s.to_int<int>; // Check overflow',data:[19.6,14.8,18.8,22.1,24.1]},
{name:'ssa s = "    123456789"; int res = s.to_int<int, false>; // No check overflow',data:[15.2,13.7,15.4,16.0,23.2]}
]}</script>

<div class="benchset" id="bs17"><h4><a id="bs182348477702821075660" href="#bs182348477702821075660">#</a>&nbsp;Convert to double &#39;1234.567e10&#39;</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string s = &quot;1234.567e10&quot;; double res = std::strtod(s.c_str(), nullptr);<span class="tooltiptext code">void ToDoubleStr(benchmark::State&amp; state, const std::string&amp; s, double c) {
    for (auto _: state) {
        char* ptr = nullptr;
        double res = std::strtod(s.c_str(), &amp;ptr);
        if (ptr == s.c_str()) {
            state.SkipWithError(&quot;not equal&quot;);
        }
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
    }
}</span></span></td><td></td><td class="benchmarkresult">64.1</td><td class="benchmarkresult">63.6</td><td class="benchmarkresult">101</td><td class="benchmarkresult">105</td><td class="benchmarkresult">198</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string_view s = &quot;1234.567e10&quot;; std::from_chars(s.data(), s.data() + s.size(), res);<span class="tooltiptext code">void ToDoubleFromChars(benchmark::State&amp; state, const std::string_view&amp; s, double c) {
    for (auto _: state) {
        double res = 0;
        if (std::from_chars(s.data(), s.data() + s.size(), res).ec != std::errc{}) {
            state.SkipWithError(&quot;not equal&quot;);
        }
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
    }
}</span></span></td><td></td><td class="benchmarkresult">24.4</td><td class="benchmarkresult">23.9</td><td class="benchmarkresult">64.1</td><td class="benchmarkresult">80.7</td><td class="benchmarkresult">107</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa s = &quot;1234.567e10&quot;; double res = *s.to_double()<span class="tooltiptext code">template&lt;typename T>
void ToDoubleSimStr(benchmark::State&amp; state, T t, double c) {
    for (auto _: state) {
        auto r = t.template to_double&lt;false>();
        if (!r) {
            state.SkipWithError(&quot;not equal&quot;);
        }
        double res = *r;
    #ifdef CHECK_RESULT
        if (res != c) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(res);
        benchmark::DoNotOptimize(t);
    }
}</span></span></td><td></td><td class="benchmarkresult">26.1</td><td class="benchmarkresult">24.6</td><td class="benchmarkresult">36.0</td><td class="benchmarkresult">36.2</td><td class="benchmarkresult">43.0</td></tr>
</tbody></table></div><script>bench_sets['Convert to double \'1234.567e10\''] = {id:'bs17', tests:[
{name:'std::string s = "1234.567e10"; double res = std::strtod(s.c_str(), nullptr);',data:[64.1,63.6,101,105,198]},
{name:'std::string_view s = "1234.567e10"; std::from_chars(s.data(), s.data() + s.size(), res);',data:[24.4,23.9,64.1,80.7,107]},
{name:'ssa s = "1234.567e10"; double res = *s.to_double()',data:[26.1,24.6,36.0,36.2,43.0]}
]}</script>

<div class="benchset" id="bs18"><h4><a id="bs96505608161678391610" href="#bs96505608161678391610">#</a>&nbsp;Append const literal of 16 bytes 64 times, 1024 total length</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::stringstream str; ... str &lt;&lt; &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">void AppendStreamConstLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        std::string result;
        std::stringstream str;
        for (size_t c = 0; c &lt; 64; c++) {
            str &lt;&lt; TEXT_16;
        }
        result = str.str();
    #ifdef CHECK_RESULT
        if (result.size() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(str);
    }
}</span></span></td><td></td><td class="benchmarkresult">1351</td><td class="benchmarkresult">1440</td><td class="benchmarkresult">4750</td><td class="benchmarkresult">5600</td><td class="benchmarkresult">4315</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string str; ... str += &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">void AppendStdStringConstLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        std::string result;
        for (size_t c = 0; c &lt; 64; c++) {
            result += TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.size() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
    }
}</span></span></td><td></td><td class="benchmarkresult">375</td><td class="benchmarkresult">389</td><td class="benchmarkresult">1063</td><td class="benchmarkresult">1313</td><td class="benchmarkresult">608</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;8> str; ... str += &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringConstLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 64; c++) {
            result += TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
    }
}</span></span></td><td></td><td class="benchmarkresult">411</td><td class="benchmarkresult">398</td><td class="benchmarkresult">730</td><td class="benchmarkresult">904</td><td class="benchmarkresult">727</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;128> str; ... str += &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringConstLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 64; c++) {
            result += TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Чем больше внутренний буфер, тем меньше раз требуется
аллокация, тем быстрее результат.
The larger the internal buffer, the fewer allocations are
required, and the faster the result.</span></span></td><td class="benchmarkresult">253</td><td class="benchmarkresult">259</td><td class="benchmarkresult">395</td><td class="benchmarkresult">569</td><td class="benchmarkresult">564</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> str; ... str += &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringConstLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 64; c++) {
            result += TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
    }
}</span></span></td><td></td><td class="benchmarkresult">232</td><td class="benchmarkresult">242</td><td class="benchmarkresult">250</td><td class="benchmarkresult">348</td><td class="benchmarkresult">466</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;1024> str; ... str += &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringConstLiteral(benchmark::State&amp; state) {
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 64; c++) {
            result += TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
    }
}</span></span></td><td></td><td class="benchmarkresult">147</td><td class="benchmarkresult">141</td><td class="benchmarkresult">156</td><td class="benchmarkresult">232</td><td class="benchmarkresult">391</td></tr>
</tbody></table></div><script>bench_sets['Append const literal of 16 bytes 64 times, 1024 total length'] = {id:'bs18', tests:[
{name:'std::stringstream str; ... str << "abbaabbaabbaabba";',data:[1351,1440,4750,5600,4315]},
{name:'std::string str; ... str += "abbaabbaabbaabba";',data:[375,389,1063,1313,608]},
{name:'lstringa<8> str; ... str += "abbaabbaabbaabba";',data:[411,398,730,904,727]},
{name:'lstringa<128> str; ... str += "abbaabbaabbaabba";',data:[253,259,395,569,564]},
{name:'lstringa<512> str; ... str += "abbaabbaabbaabba";',data:[232,242,250,348,466]},
{name:'lstringa<1024> str; ... str += "abbaabbaabbaabba";',data:[147,141,156,232,391]}
]}</script>

<div class="benchset" id="bs19"><h4><a id="bs36931044816721597850" href="#bs36931044816721597850">#</a>&nbsp;Append string of 16 bytes and const literal of 16 bytes 32 times, 1024 total length</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::stringstream str; ... str &lt;&lt; str_var &lt;&lt; &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">void AppendStreamStrConstLiteral(benchmark::State&amp; state) {
    std::string s1 = TEXT_16;
    for (auto _: state) {
        std::string result;
        std::stringstream s;
        for (size_t c = 0; c &lt; 32; c++) {
            s &lt;&lt; s1 &lt;&lt; TEXT_16;
        }
        result = s.str();
    #ifdef CHECK_RESULT
        if (result.size() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
    }
}</span></span></td><td></td><td class="benchmarkresult">1370</td><td class="benchmarkresult">1360</td><td class="benchmarkresult">4613</td><td class="benchmarkresult">5528</td><td class="benchmarkresult">4263</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string str; ... str += str_var + &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">void AppendStdStrStrConstLiteral(benchmark::State&amp; state) {
    std::string p1 = TEXT_16;
    for (auto _: state) {
        std::string result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.size() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">1263</td><td class="benchmarkresult">1352</td><td class="benchmarkresult">3808</td><td class="benchmarkresult">3948</td><td class="benchmarkresult">1852</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;8> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteral(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">474</td><td class="benchmarkresult">432</td><td class="benchmarkresult">734</td><td class="benchmarkresult">814</td><td class="benchmarkresult">801</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;128> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteral(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">331</td><td class="benchmarkresult">402</td><td class="benchmarkresult">475</td><td class="benchmarkresult">531</td><td class="benchmarkresult">707</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteral(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">318</td><td class="benchmarkresult">326</td><td class="benchmarkresult">288</td><td class="benchmarkresult">373</td><td class="benchmarkresult">609</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;1024> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteral(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">235</td><td class="benchmarkresult">253</td><td class="benchmarkresult">184</td><td class="benchmarkresult">292</td><td class="benchmarkresult">530</td></tr>
</tbody></table></div><script>bench_sets['Append string of 16 bytes and const literal of 16 bytes 32 times, 1024 total length'] = {id:'bs19', tests:[
{name:'std::stringstream str; ... str << str_var << "abbaabbaabbaabba";',data:[1370,1360,4613,5528,4263]},
{name:'std::string str; ... str += str_var + "abbaabbaabbaabba";',data:[1263,1352,3808,3948,1852]},
{name:'lstringa<8> str; ... str += str_var + "abbaabbaabbaabba";',data:[474,432,734,814,801]},
{name:'lstringa<128> str; ... str += str_var + "abbaabbaabbaabba";',data:[331,402,475,531,707]},
{name:'lstringa<512> str; ... str += str_var + "abbaabbaabbaabba";',data:[318,326,288,373,609]},
{name:'lstringa<1024> str; ... str += str_var + "abbaabbaabbaabba";',data:[235,253,184,292,530]}
]}</script>

<div class="benchset" id="bs20"><h4><a id="bs8293767858383349360" href="#bs8293767858383349360">#</a>&nbsp;Append string of 16 bytes and const literal of 16 bytes 2048 times, 65536 total length</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::stringstream str; ... str &lt;&lt; str_var &lt;&lt; &quot;abbaabbaabbaabba&quot;; 2048 times<span class="tooltiptext code">void AppendStreamStrConstLiteralBig(benchmark::State&amp; state) {
    std::string s1 = TEXT_16;
    for (auto _: state) {
        std::string result;
        std::stringstream s;
        for (size_t c = 0; c &lt; 2048; c++) {
            s &lt;&lt; s1 &lt;&lt; TEXT_16;
        }
        result = s.str();
    #ifdef CHECK_RESULT
        if (result.size() != 1024 * 64) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
    }
}</span></span></td><td></td><td class="benchmarkresult">77708</td><td class="benchmarkresult">73241</td><td class="benchmarkresult">219319</td><td class="benchmarkresult">288865</td><td class="benchmarkresult">223824</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string str; ... str += str_var + &quot;abbaabbaabbaabba&quot;; 2048 times<span class="tooltiptext code">void AppendStdStrStrConstLiteralBig(benchmark::State&amp; state) {
    std::string p1 = TEXT_16;
    for (auto _: state) {
        std::string result;
        for (size_t c = 0; c &lt; 2048; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.size() != 1024 * 64) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">72817</td><td class="benchmarkresult">72618</td><td class="benchmarkresult">194821</td><td class="benchmarkresult">189369</td><td class="benchmarkresult">107632</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;8> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;; 2048 times<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteralBig(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 2048; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024 * 64) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">18621</td><td class="benchmarkresult">19903</td><td class="benchmarkresult">18897</td><td class="benchmarkresult">24389</td><td class="benchmarkresult">40520</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;128> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;; 2048 times<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteralBig(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 2048; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024 * 64) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">18047</td><td class="benchmarkresult">17505</td><td class="benchmarkresult">17335</td><td class="benchmarkresult">22364</td><td class="benchmarkresult">37619</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;; 2048 times<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteralBig(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 2048; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024 * 64) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">15853</td><td class="benchmarkresult">17272</td><td class="benchmarkresult">16905</td><td class="benchmarkresult">21345</td><td class="benchmarkresult">36261</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;1024> str; ... str += str_var + &quot;abbaabbaabbaabba&quot;; 2048 times<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstringStrConstLiteralBig(benchmark::State&amp; state) {
    stringa p1 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 2048; c++) {
            result += p1 + TEXT_16;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024 * 64) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(p1);
    }
}</span></span></td><td></td><td class="benchmarkresult">16648</td><td class="benchmarkresult">17201</td><td class="benchmarkresult">16758</td><td class="benchmarkresult">21975</td><td class="benchmarkresult">37537</td></tr>
</tbody></table></div><script>bench_sets['Append string of 16 bytes and const literal of 16 bytes 2048 times, 65536 total length'] = {id:'bs20', tests:[
{name:'std::stringstream str; ... str << str_var << "abbaabbaabbaabba"; 2048 times',data:[77708,73241,219319,288865,223824]},
{name:'std::string str; ... str += str_var + "abbaabbaabbaabba"; 2048 times',data:[72817,72618,194821,189369,107632]},
{name:'lstringa<8> str; ... str += str_var + "abbaabbaabbaabba"; 2048 times',data:[18621,19903,18897,24389,40520]},
{name:'lstringa<128> str; ... str += str_var + "abbaabbaabbaabba"; 2048 times',data:[18047,17505,17335,22364,37619]},
{name:'lstringa<512> str; ... str += str_var + "abbaabbaabbaabba"; 2048 times',data:[15853,17272,16905,21345,36261]},
{name:'lstringa<1024> str; ... str += str_var + "abbaabbaabbaabba"; 2048 times',data:[16648,17201,16758,21975,37537]}
]}</script>

<div class="benchset" id="bs21"><h4><a id="bs66949588770596833730" href="#bs66949588770596833730">#</a>&nbsp;Append 2 string of 16 bytes 32 times, 1024 total length</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::stringstream str; ... str &lt;&lt; str_var1 &lt;&lt; str_var2;<span class="tooltiptext code">void AppendStream2String(benchmark::State&amp; state) {
    std::string s1 = TEXT_16;
    std::string s2 = TEXT_16;
    for (auto _: state) {
        std::string result;
        std::stringstream s;
        for (size_t c = 0; c &lt; 32; c++) {
            s &lt;&lt; s1 &lt;&lt; s2;
        }
        result = s.str();
    #ifdef CHECK_RESULT
        if (result.size() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
        benchmark::DoNotOptimize(s2);
    }
}</span></span></td><td></td><td class="benchmarkresult">1377</td><td class="benchmarkresult">1469</td><td class="benchmarkresult">4306</td><td class="benchmarkresult">5391</td><td class="benchmarkresult">4561</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string str; ... str += str_var1 + str_var2;<span class="tooltiptext code">void AppendStdStr2String(benchmark::State&amp; state) {
    std::string s1 = TEXT_16;
    std::string s2 = TEXT_16;

    for (auto _: state) {
        std::string result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += s1 + s2;
        }
    #ifdef CHECK_RESULT
        if (result.size() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
        benchmark::DoNotOptimize(s2);
    }
}</span></span></td><td></td><td class="benchmarkresult">1379</td><td class="benchmarkresult">1346</td><td class="benchmarkresult">3942</td><td class="benchmarkresult">3953</td><td class="benchmarkresult">2331</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;16> str; ... str += str_var1 + str_var2;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstring2String(benchmark::State&amp; state) {
    stra s1 = TEXT_16;
    stra s2 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += s1 + s2;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
        benchmark::DoNotOptimize(s2);
    }
}</span></span></td><td></td><td class="benchmarkresult">525</td><td class="benchmarkresult">512</td><td class="benchmarkresult">795</td><td class="benchmarkresult">881</td><td class="benchmarkresult">1151</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;128> str; ... str += str_var1 + str_var2;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstring2String(benchmark::State&amp; state) {
    stra s1 = TEXT_16;
    stra s2 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += s1 + s2;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
        benchmark::DoNotOptimize(s2);
    }
}</span></span></td><td></td><td class="benchmarkresult">429</td><td class="benchmarkresult">442</td><td class="benchmarkresult">530</td><td class="benchmarkresult">604</td><td class="benchmarkresult">1032</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;512> str; ... str += str_var1 + str_var2;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstring2String(benchmark::State&amp; state) {
    stra s1 = TEXT_16;
    stra s2 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += s1 + s2;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
        benchmark::DoNotOptimize(s2);
    }
}</span></span></td><td></td><td class="benchmarkresult">398</td><td class="benchmarkresult">395</td><td class="benchmarkresult">404</td><td class="benchmarkresult">449</td><td class="benchmarkresult">908</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;1024> str; ... str += str_var1 + str_var2;<span class="tooltiptext code">template&lt;unsigned N>
void AppendLstring2String(benchmark::State&amp; state) {
    stra s1 = TEXT_16;
    stra s2 = TEXT_16;
    for (auto _: state) {
        lstringa&lt;N> result;
        for (size_t c = 0; c &lt; 32; c++) {
            result += s1 + s2;
        }
    #ifdef CHECK_RESULT
        if (result.length() != 1024) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(s1);
        benchmark::DoNotOptimize(s2);
    }
}</span></span></td><td></td><td class="benchmarkresult">301</td><td class="benchmarkresult">338</td><td class="benchmarkresult">281</td><td class="benchmarkresult">394</td><td class="benchmarkresult">848</td></tr>
</tbody></table></div><script>bench_sets['Append 2 string of 16 bytes 32 times, 1024 total length'] = {id:'bs21', tests:[
{name:'std::stringstream str; ... str << str_var1 << str_var2;',data:[1377,1469,4306,5391,4561]},
{name:'std::string str; ... str += str_var1 + str_var2;',data:[1379,1346,3942,3953,2331]},
{name:'lstringa<16> str; ... str += str_var1 + str_var2;',data:[525,512,795,881,1151]},
{name:'lstringa<128> str; ... str += str_var1 + str_var2;',data:[429,442,530,604,1032]},
{name:'lstringa<512> str; ... str += str_var1 + str_var2;',data:[398,395,404,449,908]},
{name:'lstringa<1024> str; ... str += str_var1 + str_var2;',data:[301,338,281,394,848]}
]}</script>

<div class="benchset" id="bs22"><h4><a id="bs130432147582115154460" href="#bs130432147582115154460">#</a>&nbsp;Append text, number, text</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::stringstream str; str &lt;&lt; &quot;test = &quot; &lt;&lt; k &lt;&lt; &quot; times&quot;;<span class="tooltiptext code">void AppendStreamStrNumStr(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            std::stringstream t;
            t &lt;&lt; &quot;test = &quot; &lt;&lt; k &lt;&lt; &quot; times&quot;;
            std::string result = t.str();
        #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
        #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">3091</td><td class="benchmarkresult">3041</td><td class="benchmarkresult">10756</td><td class="benchmarkresult">11857</td><td class="benchmarkresult">6485</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string str = &quot;test = &quot; + std::to_string(k) + &quot; times&quot;;<span class="tooltiptext code">void AppendStdStringStrNumStr(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            std::string result = &quot;test = &quot; + std::to_string(k) + &quot; times&quot;;
        #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
        #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">470</td><td class="benchmarkresult">439</td><td class="benchmarkresult">1072</td><td class="benchmarkresult">1260</td><td class="benchmarkresult">1595</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">char buf[100]; sprintf(buf, &quot;test = %u times&quot;, k); std::string str = buf;<span class="tooltiptext code">void AppendSprintfStrNumStr(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            char buf[100];
            std::sprintf(buf, &quot;test = %u times&quot;, k);
            std::string result = buf;
        #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
        #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">1391</td><td class="benchmarkresult">1458</td><td class="benchmarkresult">2827</td><td class="benchmarkresult">2822</td><td class="benchmarkresult">2803</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::string str = std::format(&quot;test = {} times&quot;, k);<span class="tooltiptext code">void AppendFormatStrNumStr(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            std::string result = std::format(&quot;test = {} times&quot;, k);
        #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
        #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td></td><td class="benchmarkresult">1166</td><td class="benchmarkresult">1251</td><td class="benchmarkresult">1907</td><td class="benchmarkresult">2423</td><td class="benchmarkresult">2056</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;8> str; str.format(&quot;test = {} times&quot;, k);<span class="tooltiptext code">template&lt;typename T>
void AppendSimStrStrNumStrF(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            T result;
            result.format(&quot;test = {} times&quot;, k);
    #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
    #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">В simstr format с первого раза не помещается в такую строку без аллокации.
In simstr format, the first time it doesn't fit into such a
string without allocation.</span></span></td><td class="benchmarkresult">1381</td><td class="benchmarkresult">1668</td><td class="benchmarkresult">2160</td><td class="benchmarkresult">2694</td><td class="benchmarkresult">3049</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;32> str; str.format(&quot;test = {} times&quot;, k);<span class="tooltiptext code">template&lt;typename T>
void AppendSimStrStrNumStrF(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            T result;
            result.format(&quot;test = {} times&quot;, k);
    #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
    #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">А в такую помещается. Используйте сразу буфера подходящего размера.
And it fits in this one. Use buffers of the appropriate size right away.</span></span></td><td class="benchmarkresult">1111</td><td class="benchmarkresult">1103</td><td class="benchmarkresult">1009</td><td class="benchmarkresult">1520</td><td class="benchmarkresult">2473</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;8> str = &quot;test = &quot; + k + &quot; times&quot;;<span class="tooltiptext code">template&lt;typename T>
void AppendSimStrStrNumStr(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            T result = &quot;test = &quot;_ss + k + &quot; times&quot;;
    #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
    #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Результат не помещается в SSO, возникает аллокация.
The result does not fit into SSO, an allocation occurs.</span></span></td><td class="benchmarkresult">288</td><td class="benchmarkresult">313</td><td class="benchmarkresult">831</td><td class="benchmarkresult">904</td><td class="benchmarkresult">588</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">lstringa&lt;32> str = &quot;test = &quot; + k + &quot; times&quot;;<span class="tooltiptext code">template&lt;typename T>
void AppendSimStrStrNumStr(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            T result = &quot;test = &quot;_ss + k + &quot; times&quot;;
    #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
    #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">А здесь и ниже - результат укладывается в SSO.
Ещё раз - используйте сразу буфера подходящего размера.
And here and below, the result fits within SSO.
Once again, use appropriately sized buffers from the start.</span></span></td><td class="benchmarkresult">155</td><td class="benchmarkresult">148</td><td class="benchmarkresult">154</td><td class="benchmarkresult">185</td><td class="benchmarkresult">362</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">stringa str = &quot;test = &quot; + k + &quot; times&quot;;<span class="tooltiptext code">template&lt;typename T>
void AppendSimStrStrNumStr(benchmark::State&amp; state) {
    for (auto _: state) {
        for (unsigned k = 1; k &lt;= 1&#39;000&#39;000&#39;000; k *= 10) {
            T result = &quot;test = &quot;_ss + k + &quot; times&quot;;
    #ifdef CHECK_RESULT
            if (!result.starts_with(&quot;test = &quot;) || !result.ends_with(&quot; times&quot;)) {
                state.SkipWithError(&quot;not equal&quot;);
                break;
            }
    #endif
            benchmark::DoNotOptimize(result);
            benchmark::DoNotOptimize(k);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Под WASM размер SSO 15 символов, что явно не хватает для размещения
результата, отсюда и такое время.
Under WASM, the SSO size is 15 characters, which is clearly not
enough to accommodate the result, hence the long time.</span></span></td><td class="benchmarkresult">146</td><td class="benchmarkresult">162</td><td class="benchmarkresult">151</td><td class="benchmarkresult">243</td><td class="benchmarkresult">556</td></tr>
</tbody></table></div><script>bench_sets['Append text, number, text'] = {id:'bs22', tests:[
{name:'std::stringstream str; str << "test = " << k << " times";',data:[3091,3041,10756,11857,6485]},
{name:'std::string str = "test = " + std::to_string(k) + " times";',data:[470,439,1072,1260,1595]},
{name:'char buf[100]; sprintf(buf, "test = %u times", k); std::string str = buf;',data:[1391,1458,2827,2822,2803]},
{name:'std::string str = std::format("test = {} times", k);',data:[1166,1251,1907,2423,2056]},
{name:'lstringa<8> str; str.format("test = {} times", k);',data:[1381,1668,2160,2694,3049]},
{name:'lstringa<32> str; str.format("test = {} times", k);',data:[1111,1103,1009,1520,2473]},
{name:'lstringa<8> str = "test = " + k + " times";',data:[288,313,831,904,588]},
{name:'lstringa<32> str = "test = " + k + " times";',data:[155,148,154,185,362]},
{name:'stringa str = "test = " + k + " times";',data:[146,162,151,243,556]}
]}</script>

<div class="benchset" id="bs23"><h4><a id="bs7106975351756760120" href="#bs7106975351756760120">#</a>&nbsp;Split text and convert to int</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">std::string::find + substr + std::strtol<span class="tooltiptext code">void SplitConvertIntStdString(benchmark::State&amp; state) {
    std::string numbers = NUMBER_LIST;
    for (auto _: state) {
        int total = 0;
        for (size_t start = 0; start &lt; numbers.length(); ) {
            int delim = numbers.find(&quot;-!-&quot;, start);
            if (delim == std::string::npos) {
                delim = numbers.size();
            }
            std::string part = numbers.substr(start, delim - start);
            total += std::strtol(part.c_str(), nullptr, 0);
            start = delim + 3;
        }
    #ifdef CHECK_RESULT
        if (total != 218) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(total);
        benchmark::DoNotOptimize(numbers);
    }
}</span></span></td><td></td><td class="benchmarkresult">271</td><td class="benchmarkresult">279</td><td class="benchmarkresult">540</td><td class="benchmarkresult">550</td><td class="benchmarkresult">619</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa::splitter + ssa::as_int<span class="tooltiptext code">void SplitConvertIntSimStr(benchmark::State&amp; state) {
    stra numbers = NUMBER_LIST;
    for (auto _: state) {
        int total = 0;
        for (auto splitter = numbers.splitter(&quot;-!-&quot;); !splitter.is_done();) {
            total += splitter.next().as_int&lt;int>();
        }
    #ifdef CHECK_RESULT
        if (total != 218) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(total);
        benchmark::DoNotOptimize(numbers);
    }
}</span></span></td><td></td><td class="benchmarkresult">162</td><td class="benchmarkresult">144</td><td class="benchmarkresult">168</td><td class="benchmarkresult">292</td><td class="benchmarkresult">274</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">ssa::splitf + functor<span class="tooltiptext code">void SplitConvertIntSplitf(benchmark::State&amp; state) {
    stra numbers = NUMBER_LIST;
    for (auto _: state) {
        int total = 0;
        numbers.splitf&lt;void>(&quot;-!-&quot;, [&amp;](ssa&amp; part){total += part.as_int&lt;int>();});
    #ifdef CHECK_RESULT
        if (total != 218) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
    #endif
        benchmark::DoNotOptimize(total);
        benchmark::DoNotOptimize(numbers);
    }
}</span></span></td><td></td><td class="benchmarkresult">212</td><td class="benchmarkresult">130</td><td class="benchmarkresult">191</td><td class="benchmarkresult">217</td><td class="benchmarkresult">332</td></tr>
</tbody></table></div><script>bench_sets['Split text and convert to int'] = {id:'bs23', tests:[
{name:'std::string::find + substr + std::strtol',data:[271,279,540,550,619]},
{name:'ssa::splitter + ssa::as_int',data:[162,144,168,292,274]},
{name:'ssa::splitf + functor',data:[212,130,191,217,332]}
]}</script>

<div class="benchset" id="bs24"><h4><a id="bs151373809886162287550" href="#bs151373809886162287550">#</a>&nbsp;Replace symbols in text ~400 symbols</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">Naive (and wrong) replace symbols with std::string find + replace<span class="tooltiptext code">void ReplaceSymbolsStdStringNaiveWrong(benchmark::State&amp; state) {
    std::string_view source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        ;
    std::vector&lt;std::pair&lt;u8s, std::string_view>> repl = {
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;}
    };

    auto repl_all = [](std::string&amp; str, char s, std::string_view repl) {
        size_t start_pos = 0;
        while((start_pos = str.find(s, start_pos)) != std::string::npos) {
            str.replace(start_pos, 1, repl);
            start_pos += repl.length();
        }
    };
    for (auto _: state) {
        std::string result{source};
        for (const auto&amp; r : repl) {
            repl_all(result, r.first, r.second);
        }
#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Это наивная реализация, которая неверно отработает на
таких заменах, как 'a'->'b' и 'b'->'a'. Но если замены не конфликтуют,
то работает быстро.
This is a naive implementation that will fail to handle substitutions
such as 'a'->'b' and 'b'->'a'. But if the substitutions don't conflict,
it works quickly.</span></span></td><td class="benchmarkresult">882</td><td class="benchmarkresult">827</td><td class="benchmarkresult">1089</td><td class="benchmarkresult">1176</td><td class="benchmarkresult">2905</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace symbols with std::string find_first_of + replace<span class="tooltiptext code">void ReplaceSymbolsStdStringNaiveRight(benchmark::State&amp; state) {
    std::string_view source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        ;
    std::vector&lt;std::pair&lt;u8s, std::string_view>> repl = {
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;},
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
    };

    for (auto _: state) {
        std::string result{source};
        std::string pattern;
        for (const auto&amp; r : repl) {
            pattern += r.first;
        }
        size_t start_pos = 0;
        while((start_pos = result.find_first_of(pattern, start_pos)) != std::string::npos) {
            size_t idx = pattern.find(result[start_pos]);
            result.replace(start_pos, 1, repl[idx].second);
            start_pos += repl[idx].second.length();
        }
#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Дальше уже правильные реализации, не зависящие от конфликтующих замен.
Further, there are correct implementations that do not depend on
conflicting replacements.</span></span></td><td class="benchmarkresult">2453</td><td class="benchmarkresult">2391</td><td class="benchmarkresult">2072</td><td class="benchmarkresult">2155</td><td class="benchmarkresult">3870</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace symbols with std::string_view find_first_of + copy<span class="tooltiptext code">void ReplaceSymbolsStdString(benchmark::State&amp; state) {
    std::string_view source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        ;

    const std::string_view repl_from = &quot;-&lt;>&#39;\&quot;&amp;&quot;;
    const std::string_view repl_to[] = {&quot;&quot;, &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, &quot;&amp;#39;&quot;, &quot;&amp;quot;&quot;, &quot;&amp;amp;&quot;};

    for (auto _: state) {
        std::string result;

        for (size_t start = 0; start &lt; source.size();) {
            size_t idx = source.find_first_of(repl_from, start);
            if (idx == std::string::npos) {
                result += source.substr(start);
                break;
            }
            if (idx > start) {
                result += source.substr(start, idx - start);
            }
            size_t what = repl_from.find(source[idx]);
            result += repl_to[what];

            start = idx + 1;
        }
#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">1112</td><td class="benchmarkresult">1089</td><td class="benchmarkresult">2459</td><td class="benchmarkresult">2546</td><td class="benchmarkresult">2942</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace runtime symbols with string expressions and without remembering all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ReplaceSymbolsDynPatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        ;

    std::vector&lt;std::pair&lt;u8s, ssa>> repl = {
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;},
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
    };

    for (auto _: state) {
        stringa result = expr_replace_symbols&lt;u8s, UseVector>{source, repl};

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">1268</td><td class="benchmarkresult">1478</td><td class="benchmarkresult">1413</td><td class="benchmarkresult">1595</td><td class="benchmarkresult">3121</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace runtime symbols with simstr and memorization of all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ReplaceSymbolsDynPatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        ;

    std::vector&lt;std::pair&lt;u8s, ssa>> repl = {
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;},
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
    };

    for (auto _: state) {
        stringa result = expr_replace_symbols&lt;u8s, UseVector>{source, repl};

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">1058</td><td class="benchmarkresult">1013</td><td class="benchmarkresult">1334</td><td class="benchmarkresult">1418</td><td class="benchmarkresult">2807</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace const symbols with string expressions and without remembering all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ReplaceSymbolsCons2PatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        ;

    for (auto _: state) {
        stringa result = e_repl_const_symbols&lt;UseVector>(source,
            &#39;-&#39;, &quot;&quot;,
            &#39;&lt;&#39;, &quot;&amp;lt;&quot;,
            &#39;>&#39;, &quot;&amp;gt;&quot;,
            &#39;\&#39;&#39;, &quot;&amp;#39;&quot;,
            &#39;\&quot;&#39;, &quot;&amp;quot;&quot;,
            &#39;&amp;&#39;, &quot;&amp;amp;&quot;
        );

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">1016</td><td class="benchmarkresult">1247</td><td class="benchmarkresult">1140</td><td class="benchmarkresult">1290</td><td class="benchmarkresult">2448</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace const symbols with string expressions and memorization of all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ReplaceSymbolsCons2PatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        &quot; ksjd-fksjd \&quot;dkjfs-jkhdf dfj &#39; kdkd \&quot;dkfdkfkdjf&quot;
        ;

    for (auto _: state) {
        stringa result = e_repl_const_symbols&lt;UseVector>(source,
            &#39;-&#39;, &quot;&quot;,
            &#39;&lt;&#39;, &quot;&amp;lt;&quot;,
            &#39;>&#39;, &quot;&amp;gt;&quot;,
            &#39;\&#39;&#39;, &quot;&amp;#39;&quot;,
            &#39;\&quot;&#39;, &quot;&amp;quot;&quot;,
            &#39;&amp;&#39;, &quot;&amp;amp;&quot;
        );

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
            &quot; ksjdfksjd &amp;quot;dkjfsjkhdf dfj &amp;#39; kdkd &amp;quot;dkfdkfkdjf&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">906</td><td class="benchmarkresult">897</td><td class="benchmarkresult">1280</td><td class="benchmarkresult">1249</td><td class="benchmarkresult">2383</td></tr>
</tbody></table></div><script>bench_sets['Replace symbols in text ~400 symbols'] = {id:'bs24', tests:[
{name:'Naive (and wrong) replace symbols with std::string find + replace',data:[882,827,1089,1176,2905]},
{name:'replace symbols with std::string find_first_of + replace',data:[2453,2391,2072,2155,3870]},
{name:'replace symbols with std::string_view find_first_of + copy',data:[1112,1089,2459,2546,2942]},
{name:'replace runtime symbols with string expressions and without remembering all search results',data:[1268,1478,1413,1595,3121]},
{name:'replace runtime symbols with simstr and memorization of all search results',data:[1058,1013,1334,1418,2807]},
{name:'replace const symbols with string expressions and without remembering all search results',data:[1016,1247,1140,1290,2448]},
{name:'replace const symbols with string expressions and memorization of all search results',data:[906,897,1280,1249,2383]}
]}</script>

<div class="benchset" id="bs25"><h4><a id="bs96756339547767401190" href="#bs96756339547767401190">#</a>&nbsp;Replace symbols in text ~40 symbols</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">Short Naive (and wrong) replace symbols with std::string find + replace<span class="tooltiptext code">void ShortReplaceSymbolsStdStringNaiveWrong(benchmark::State&amp; state) {
    std::string_view source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        ;
    std::vector&lt;std::pair&lt;u8s, std::string_view>> repl = {
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;}
    };

    auto repl_all = [](std::string&amp; str, char s, std::string_view repl) {
        size_t start_pos = 0;
        while((start_pos = str.find(s, start_pos)) != std::string::npos) {
            str.replace(start_pos, 1, repl);
            start_pos += repl.length();
        }
    };
    for (auto _: state) {
        std::string result{source};
        for (const auto&amp; r : repl) {
            repl_all(result, r.first, r.second);
        }
#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">165</td><td class="benchmarkresult">162</td><td class="benchmarkresult">314</td><td class="benchmarkresult">338</td><td class="benchmarkresult">429</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Short replace symbols with std::string find_first_of + replace<span class="tooltiptext code">void ShortReplaceSymbolsStdStringNaiveRight(benchmark::State&amp; state) {
    std::string_view source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        ;
    std::vector&lt;std::pair&lt;u8s, std::string_view>> repl = {
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;},
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
    };

    for (auto _: state) {
        std::string result{source};
        std::string pattern;
        for (const auto&amp; r : repl) {
            pattern += r.first;
        }
        size_t start_pos = 0;
        while((start_pos = result.find_first_of(pattern, start_pos)) != std::string::npos) {
            size_t idx = pattern.find(result[start_pos]);
            result.replace(start_pos, 1, repl[idx].second);
            start_pos += repl[idx].second.length();
        }
#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">317</td><td class="benchmarkresult">302</td><td class="benchmarkresult">368</td><td class="benchmarkresult">439</td><td class="benchmarkresult">526</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Short replace symbols with std::string_view find_first_of + copy<span class="tooltiptext code">void ShortReplaceSymbolsStdString(benchmark::State&amp; state) {
    std::string_view source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        ;

    const std::string_view repl_from = &quot;-&lt;>&#39;\&quot;&amp;&quot;;
    const std::string_view repl_to[] = {&quot;&quot;, &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, &quot;&amp;#39;&quot;, &quot;&amp;quot;&quot;, &quot;&amp;amp;&quot;};

    for (auto _: state) {
        std::string result;

        for (size_t start = 0; start &lt; source.size();) {
            size_t idx = source.find_first_of(repl_from, start);
            if (idx == std::string::npos) {
                result += source.substr(start);
                break;
            }
            if (idx > start) {
                result += source.substr(start, idx - start);
            }
            size_t what = repl_from.find_first_of(source[idx]);
            result += repl_to[what];

            start = idx + 1;
        }
#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">164</td><td class="benchmarkresult">159</td><td class="benchmarkresult">326</td><td class="benchmarkresult">375</td><td class="benchmarkresult">413</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Short replace runtime symbols with string expressions and without remembering all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ShortReplaceSymbolsDynPatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        ;

    std::vector&lt;std::pair&lt;u8s, ssa>> repl = {
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;},
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
    };

    for (auto _: state) {
        stringa result = expr_replace_symbols&lt;u8s, UseVector>{source, repl};

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">174</td><td class="benchmarkresult">190</td><td class="benchmarkresult">266</td><td class="benchmarkresult">310</td><td class="benchmarkresult">390</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Short replace runtime symbols with simstr and memorization of all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ShortReplaceSymbolsDynPatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        ;

    std::vector&lt;std::pair&lt;u8s, ssa>> repl = {
        {&#39;-&#39;, &quot;&quot;},
        {&#39;&lt;&#39;, &quot;&amp;lt;&quot;},
        {&#39;>&#39;, &quot;&amp;gt;&quot;},
        {&#39;\&#39;&#39;, &quot;&amp;#39;&quot;},
        {&#39;\&quot;&#39;, &quot;&amp;quot;&quot;},
        {&#39;&amp;&#39;, &quot;&amp;amp;&quot;},
    };

    for (auto _: state) {
        stringa result = expr_replace_symbols&lt;u8s, UseVector>{source, repl};

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">183</td><td class="benchmarkresult">196</td><td class="benchmarkresult">374</td><td class="benchmarkresult">394</td><td class="benchmarkresult">403</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Short replace const symbols with string expressions and without remembering all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ShortReplaceSymbolsCons2PatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        ;

    for (auto _: state) {
        stringa result = e_repl_const_symbols&lt;UseVector>(source,
            &#39;-&#39;, &quot;&quot;,
            &#39;&lt;&#39;, &quot;&amp;lt;&quot;,
            &#39;>&#39;, &quot;&amp;gt;&quot;,
            &#39;\&#39;&#39;, &quot;&amp;#39;&quot;,
            &#39;\&quot;&#39;, &quot;&amp;quot;&quot;,
            &#39;&amp;&#39;, &quot;&amp;amp;&quot;
        );

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">134</td><td class="benchmarkresult">162</td><td class="benchmarkresult">217</td><td class="benchmarkresult">267</td><td class="benchmarkresult">243</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Short replace const symbols with string expressions and memorization of all search results<span class="tooltiptext code">template&lt;bool UseVector>
void ShortReplaceSymbolsCons2PatternSimStr(benchmark::State&amp; state) {
    stra source =
        &quot;abcdefg124 &lt; jhsfjsh sjdfsh jfhjd &amp;&amp; jdjdj >&quot;
        ;

    for (auto _: state) {
        stringa result = e_repl_const_symbols&lt;UseVector>(source,
            &#39;-&#39;, &quot;&quot;,
            &#39;&lt;&#39;, &quot;&amp;lt;&quot;,
            &#39;>&#39;, &quot;&amp;gt;&quot;,
            &#39;\&#39;&#39;, &quot;&amp;#39;&quot;,
            &#39;\&quot;&#39;, &quot;&amp;quot;&quot;,
            &#39;&amp;&#39;, &quot;&amp;amp;&quot;
        );

#ifdef CHECK_RESULT
        if (result
            !=
            &quot;abcdefg124 &amp;lt; jhsfjsh sjdfsh jfhjd &amp;amp;&amp;amp; jdjdj &amp;gt;&quot;
        ) {
            state.SkipWithError(&quot;not equal&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">150</td><td class="benchmarkresult">165</td><td class="benchmarkresult">315</td><td class="benchmarkresult">352</td><td class="benchmarkresult">313</td></tr>
</tbody></table></div><script>bench_sets['Replace symbols in text ~40 symbols'] = {id:'bs25', tests:[
{name:'Short Naive (and wrong) replace symbols with std::string find + replace',data:[165,162,314,338,429]},
{name:'Short replace symbols with std::string find_first_of + replace',data:[317,302,368,439,526]},
{name:'Short replace symbols with std::string_view find_first_of + copy',data:[164,159,326,375,413]},
{name:'Short replace runtime symbols with string expressions and without remembering all search results',data:[174,190,266,310,390]},
{name:'Short replace runtime symbols with simstr and memorization of all search results',data:[183,196,374,394,403]},
{name:'Short replace const symbols with string expressions and without remembering all search results',data:[134,162,217,267,243]},
{name:'Short replace const symbols with string expressions and memorization of all search results',data:[150,165,315,352,313]}
]}</script>

<div class="benchset" id="bs26"><h4><a id="bs77745698784557935900" href="#bs77745698784557935900">#</a>&nbsp;Replace All Str To Longer Size</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in std::string|64<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllLongerStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;----&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">164</td><td class="benchmarkresult">174</td><td class="benchmarkresult">228</td><td class="benchmarkresult">243</td><td class="benchmarkresult">382</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in std::string|256<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllLongerStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;----&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">542</td><td class="benchmarkresult">524</td><td class="benchmarkresult">754</td><td class="benchmarkresult">818</td><td class="benchmarkresult">1318</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in std::string|512<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllLongerStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;----&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">1016</td><td class="benchmarkresult">949</td><td class="benchmarkresult">1411</td><td class="benchmarkresult">1492</td><td class="benchmarkresult">2632</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in std::string|1024<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllLongerStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;----&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">2221</td><td class="benchmarkresult">2201</td><td class="benchmarkresult">3115</td><td class="benchmarkresult">3206</td><td class="benchmarkresult">5262</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in std::string|2048<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllLongerStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;----&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">6213</td><td class="benchmarkresult">5758</td><td class="benchmarkresult">8203</td><td class="benchmarkresult">8058</td><td class="benchmarkresult">12723</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in lstringa&lt;8>|64<span class="tooltiptext code">template&lt;size_t N, size_t Count>
void ReplaceAllLongerSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">140</td><td class="benchmarkresult">156</td><td class="benchmarkresult">231</td><td class="benchmarkresult">251</td><td class="benchmarkresult">296</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in lstringa&lt;8>|256<span class="tooltiptext code">template&lt;size_t N, size_t Count>
void ReplaceAllLongerSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">429</td><td class="benchmarkresult">493</td><td class="benchmarkresult">624</td><td class="benchmarkresult">670</td><td class="benchmarkresult">1106</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in lstringa&lt;8>|512<span class="tooltiptext code">template&lt;size_t N, size_t Count>
void ReplaceAllLongerSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">811</td><td class="benchmarkresult">979</td><td class="benchmarkresult">1021</td><td class="benchmarkresult">1168</td><td class="benchmarkresult">1998</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in lstringa&lt;8>|1024<span class="tooltiptext code">template&lt;size_t N, size_t Count>
void ReplaceAllLongerSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">1718</td><td class="benchmarkresult">1881</td><td class="benchmarkresult">1832</td><td class="benchmarkresult">2054</td><td class="benchmarkresult">3708</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- in lstringa&lt;8>|2048<span class="tooltiptext code">template&lt;size_t N, size_t Count>
void ReplaceAllLongerSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">3151</td><td class="benchmarkresult">3456</td><td class="benchmarkresult">3573</td><td class="benchmarkresult">3914</td><td class="benchmarkresult">7236</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- by init stringa|64<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllLongerSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">95.8</td><td class="benchmarkresult">100.0</td><td class="benchmarkresult">179</td><td class="benchmarkresult">215</td><td class="benchmarkresult">208</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- by init stringa|256<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllLongerSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">303</td><td class="benchmarkresult">306</td><td class="benchmarkresult">384</td><td class="benchmarkresult">497</td><td class="benchmarkresult">745</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- by init stringa|512<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllLongerSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">731</td><td class="benchmarkresult">728</td><td class="benchmarkresult">825</td><td class="benchmarkresult">1064</td><td class="benchmarkresult">1649</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- by init stringa|1024<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllLongerSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">1576</td><td class="benchmarkresult">1640</td><td class="benchmarkresult">1750</td><td class="benchmarkresult">2210</td><td class="benchmarkresult">3458</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to ---- by init stringa|2048<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllLongerSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa----baaaaaaaa--------aaaaabaaaaaaaaaaaaaaaaaaaaa----a&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;----&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">3037</td><td class="benchmarkresult">3320</td><td class="benchmarkresult">3143</td><td class="benchmarkresult">4723</td><td class="benchmarkresult">7119</td></tr>
</tbody></table></div><script>bench_sets['Replace All Str To Longer Size'] = {id:'bs26', tests:[
{name:'replace bb to ---- in std::string|64',data:[164,174,228,243,382]},
{name:'replace bb to ---- in std::string|256',data:[542,524,754,818,1318]},
{name:'replace bb to ---- in std::string|512',data:[1016,949,1411,1492,2632]},
{name:'replace bb to ---- in std::string|1024',data:[2221,2201,3115,3206,5262]},
{name:'replace bb to ---- in std::string|2048',data:[6213,5758,8203,8058,12723]},
{name:'replace bb to ---- in lstringa<8>|64',data:[140,156,231,251,296]},
{name:'replace bb to ---- in lstringa<8>|256',data:[429,493,624,670,1106]},
{name:'replace bb to ---- in lstringa<8>|512',data:[811,979,1021,1168,1998]},
{name:'replace bb to ---- in lstringa<8>|1024',data:[1718,1881,1832,2054,3708]},
{name:'replace bb to ---- in lstringa<8>|2048',data:[3151,3456,3573,3914,7236]},
{name:'replace bb to ---- by init stringa|64',data:[95.8,100.0,179,215,208]},
{name:'replace bb to ---- by init stringa|256',data:[303,306,384,497,745]},
{name:'replace bb to ---- by init stringa|512',data:[731,728,825,1064,1649]},
{name:'replace bb to ---- by init stringa|1024',data:[1576,1640,1750,2210,3458]},
{name:'replace bb to ---- by init stringa|2048',data:[3037,3320,3143,4723,7119]}
]}</script>

<div class="benchset" id="bs27"><h4><a id="bs74494088982050398630" href="#bs74494088982050398630">#</a>&nbsp;Replace All Str To Same Size</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in std::string|64<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllEqualStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;--&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">117</td><td class="benchmarkresult">123</td><td class="benchmarkresult">198</td><td class="benchmarkresult">214</td><td class="benchmarkresult">275</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in std::string|256<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllEqualStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;--&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">397</td><td class="benchmarkresult">369</td><td class="benchmarkresult">476</td><td class="benchmarkresult">535</td><td class="benchmarkresult">1017</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in std::string|512<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllEqualStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;--&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">765</td><td class="benchmarkresult">758</td><td class="benchmarkresult">838</td><td class="benchmarkresult">958</td><td class="benchmarkresult">1834</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in std::string|1024<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllEqualStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;--&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">1439</td><td class="benchmarkresult">1475</td><td class="benchmarkresult">1609</td><td class="benchmarkresult">1831</td><td class="benchmarkresult">3524</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in std::string|2048<span class="tooltiptext code">template&lt;size_t Long>
void ReplaceAllEqualStdString(benchmark::State&amp; state) {
    std::string_view source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    std::string_view sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    std::string_view pattern = &quot;bb&quot;;
    std::string_view repl = &quot;--&quot;;

    std::string big_source, big_sample;
    for (int i = 0; i &lt; Long; i++) {
        big_source += source;
        big_sample += sample;
    }

    for (auto _: state) {
        std::string result{big_source};
        size_t start_pos = 0;
        while((start_pos = result.find(pattern, start_pos)) != std::string::npos) {
            result.replace(start_pos, pattern.length(), repl);
            start_pos += repl.length();
        }
#ifdef CHECK_RESULT
        if (result != big_sample) {
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">2951</td><td class="benchmarkresult">2805</td><td class="benchmarkresult">3121</td><td class="benchmarkresult">3701</td><td class="benchmarkresult">7031</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in lstringa&lt;8>|64<span class="tooltiptext code">template&lt;size_t N, size_t Long>
void ReplaceAllEqualSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    lstringa&lt;2048> big_source{Long, source}, big_sample{Long, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;--&quot;);

        #ifdef CHECK_RESULT
    if (result.to_str() != big_sample) {
        std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
        state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">105</td><td class="benchmarkresult">98.2</td><td class="benchmarkresult">185</td><td class="benchmarkresult">195</td><td class="benchmarkresult">217</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in lstringa&lt;8>|256<span class="tooltiptext code">template&lt;size_t N, size_t Long>
void ReplaceAllEqualSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    lstringa&lt;2048> big_source{Long, source}, big_sample{Long, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;--&quot;);

        #ifdef CHECK_RESULT
    if (result.to_str() != big_sample) {
        std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
        state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">286</td><td class="benchmarkresult">296</td><td class="benchmarkresult">445</td><td class="benchmarkresult">459</td><td class="benchmarkresult">764</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in lstringa&lt;8>|512<span class="tooltiptext code">template&lt;size_t N, size_t Long>
void ReplaceAllEqualSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    lstringa&lt;2048> big_source{Long, source}, big_sample{Long, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;--&quot;);

        #ifdef CHECK_RESULT
    if (result.to_str() != big_sample) {
        std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
        state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">537</td><td class="benchmarkresult">579</td><td class="benchmarkresult">763</td><td class="benchmarkresult">853</td><td class="benchmarkresult">1417</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in lstringa&lt;8>|1024<span class="tooltiptext code">template&lt;size_t N, size_t Long>
void ReplaceAllEqualSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    lstringa&lt;2048> big_source{Long, source}, big_sample{Long, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;--&quot;);

        #ifdef CHECK_RESULT
    if (result.to_str() != big_sample) {
        std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
        state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">1098</td><td class="benchmarkresult">1109</td><td class="benchmarkresult">1417</td><td class="benchmarkresult">1489</td><td class="benchmarkresult">2732</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- in lstringa&lt;8>|2048<span class="tooltiptext code">template&lt;size_t N, size_t Long>
void ReplaceAllEqualSimString(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    lstringa&lt;2048> big_source{Long, source}, big_sample{Long, sample};

    for (auto _: state) {
        lstringa&lt;N> result = big_source;
        result.replace(&quot;bb&quot;, &quot;--&quot;);

        #ifdef CHECK_RESULT
    if (result.to_str() != big_sample) {
        std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
        state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
    }
}</span></span></td><td></td><td class="benchmarkresult">2289</td><td class="benchmarkresult">2138</td><td class="benchmarkresult">2763</td><td class="benchmarkresult">2860</td><td class="benchmarkresult">5398</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- by init stringa|64<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllEqualSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    ssa pattern = &quot;bb&quot;;
    ssa repl = &quot;--&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;--&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">84.6</td><td class="benchmarkresult">96.7</td><td class="benchmarkresult">172</td><td class="benchmarkresult">178</td><td class="benchmarkresult">183</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- by init stringa|256<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllEqualSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    ssa pattern = &quot;bb&quot;;
    ssa repl = &quot;--&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;--&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">246</td><td class="benchmarkresult">279</td><td class="benchmarkresult">361</td><td class="benchmarkresult">403</td><td class="benchmarkresult">637</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- by init stringa|512<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllEqualSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    ssa pattern = &quot;bb&quot;;
    ssa repl = &quot;--&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;--&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">442</td><td class="benchmarkresult">521</td><td class="benchmarkresult">568</td><td class="benchmarkresult">719</td><td class="benchmarkresult">1165</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- by init stringa|1024<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllEqualSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    ssa pattern = &quot;bb&quot;;
    ssa repl = &quot;--&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;--&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">910</td><td class="benchmarkresult">1034</td><td class="benchmarkresult">1050</td><td class="benchmarkresult">1181</td><td class="benchmarkresult">2294</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">replace bb to -- by init stringa|2048<span class="tooltiptext code">template&lt;size_t Count>
void ReplaceAllEqualSimStringExpr(benchmark::State&amp; state) {
    ssa source = &quot;aaaaaaaaaaaaaaaaaaabbbaaaaaaaabbbbaaaaabaaaaaaaaaaaaaaaaaaaaabba&quot;;
    ssa sample = &quot;aaaaaaaaaaaaaaaaaaa--baaaaaaaa----aaaaabaaaaaaaaaaaaaaaaaaaaa--a&quot;;
    ssa pattern = &quot;bb&quot;;
    ssa repl = &quot;--&quot;;

    lstringa&lt;2048> big_source{Count, source}, big_sample{Count, sample};

    for (auto _: state) {
        stringa result = e_repl(big_source.to_str(), &quot;bb&quot;, &quot;--&quot;);

#ifdef CHECK_RESULT
        if (result.to_str() != big_sample) {
            std::cout &lt;&lt; result.length() &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; &quot;\n\n&quot; &lt;&lt; big_sample.length() &lt;&lt; &quot;: &quot; &lt;&lt; big_sample &lt;&lt; &quot;\n\n&quot;;
            state.SkipWithError(&quot;error in replace&quot;);
            break;
        }
#endif
        benchmark::DoNotOptimize(result);
        benchmark::DoNotOptimize(source);
        benchmark::DoNotOptimize(pattern);
        benchmark::DoNotOptimize(repl);
    }
}</span></span></td><td></td><td class="benchmarkresult">1788</td><td class="benchmarkresult">1964</td><td class="benchmarkresult">1968</td><td class="benchmarkresult">2295</td><td class="benchmarkresult">4391</td></tr>
</tbody></table></div><script>bench_sets['Replace All Str To Same Size'] = {id:'bs27', tests:[
{name:'replace bb to -- in std::string|64',data:[117,123,198,214,275]},
{name:'replace bb to -- in std::string|256',data:[397,369,476,535,1017]},
{name:'replace bb to -- in std::string|512',data:[765,758,838,958,1834]},
{name:'replace bb to -- in std::string|1024',data:[1439,1475,1609,1831,3524]},
{name:'replace bb to -- in std::string|2048',data:[2951,2805,3121,3701,7031]},
{name:'replace bb to -- in lstringa<8>|64',data:[105,98.2,185,195,217]},
{name:'replace bb to -- in lstringa<8>|256',data:[286,296,445,459,764]},
{name:'replace bb to -- in lstringa<8>|512',data:[537,579,763,853,1417]},
{name:'replace bb to -- in lstringa<8>|1024',data:[1098,1109,1417,1489,2732]},
{name:'replace bb to -- in lstringa<8>|2048',data:[2289,2138,2763,2860,5398]},
{name:'replace bb to -- by init stringa|64',data:[84.6,96.7,172,178,183]},
{name:'replace bb to -- by init stringa|256',data:[246,279,361,403,637]},
{name:'replace bb to -- by init stringa|512',data:[442,521,568,719,1165]},
{name:'replace bb to -- by init stringa|1024',data:[910,1034,1050,1181,2294]},
{name:'replace bb to -- by init stringa|2048',data:[1788,1964,1968,2295,4391]}
]}</script>

<div class="benchset" id="bs28"><h4><a id="bs8410196985047277720" href="#bs8410196985047277720">#</a>&nbsp;Hash Map insert and find</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">hashStrMapA&lt;size_t> emplace &amp; find stringa;<span class="tooltiptext code">void HashMapSimStr(benchmark::State&amp; state) {
    for (auto _: state) {
        hashStrMapA&lt;size_t> store;
        for (size_t idx = 0; idx &lt; bs_sim.size(); idx++) {
            store.try_emplace(bs_sim[idx], idx);
        }
#ifdef CHECK_RESULT
        if (store.size() != bs_sim.size()) {
            state.SkipWithError(&quot;bad inserts&quot;);
        }
#endif
        for (size_t idx = 0; idx &lt; bs_sim.size(); idx++) {
            auto find = store.find(bs_sim[idx]);
            size_t res = find->second;
#ifdef CHECK_RESULT
            if (res != idx) {
                state.SkipWithError(&quot;bad find&quot;);
            }
#endif
            benchmark::DoNotOptimize(res);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Вставляем в hashStrMapA 10000 stringa длиной от 30 до 50
символов, а потом ищем их в ней
We insert 10,000 strings of length from 30 to 50 characters into
hashStrMapA, and then search for them in it.</span></span></td><td class="benchmarkresult">3707397</td><td class="benchmarkresult">3720534</td><td class="benchmarkresult">3812101</td><td class="benchmarkresult">4223565</td><td class="benchmarkresult">3100858</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::unordered_map&lt;std::string, size_t> emplace &amp; find std::string;<span class="tooltiptext code">void HashMapStdStr(benchmark::State&amp; state) {
    for (auto _: state) {
        std::unordered_map&lt;std::string, size_t> store;
        for (size_t idx = 0; idx &lt; bs_std.size(); idx++) {
            store.try_emplace(bs_std[idx], idx);
        }
#ifdef CHECK_RESULT
        if (store.size() != bs_std.size()) {
            state.SkipWithError(&quot;bad inserts&quot;);
        }
#endif
        for (size_t idx = 0; idx &lt; bs_std.size(); idx++) {
            auto find = store.find(bs_std[idx]);
            size_t res = find->second;
#ifdef CHECK_RESULT
            if (res != idx) {
                state.SkipWithError(&quot;bad find&quot;);
            }
#endif
            benchmark::DoNotOptimize(res);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">То же самое c std::string и std::unordered_map
Same thing with std::string and std::unordered_map</span></span></td><td class="benchmarkresult">3464746</td><td class="benchmarkresult">3566994</td><td class="benchmarkresult">5442291</td><td class="benchmarkresult">5280639</td><td class="benchmarkresult">3377674</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">hashStrMapA&lt;size_t> emplace &amp; find ssa;<span class="tooltiptext code">void HashMapSimSsa(benchmark::State&amp; state) {
    for (auto _: state) {
        hashStrMapA&lt;size_t> store;
        for (size_t idx = 0; idx &lt; bs_sim.size(); idx++) {
            store.emplace(bs_sim[idx], idx);
        }
#ifdef CHECK_RESULT
        if (store.size() != bs_sim.size()) {
            state.SkipWithError(&quot;bad inserts&quot;);
        }
#endif
        for (size_t idx = 0; idx &lt; bs_sim.size(); idx++) {
            ssa key = bs_sim[idx];
            auto find = store.find(key);
            size_t res = find->second;
#ifdef CHECK_RESULT
            if (res != idx) {
                state.SkipWithError(&quot;bad find&quot;);
            }
#endif
            benchmark::DoNotOptimize(res);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Теперь вставляем stringa, а ищем ssa
Now we insert stringa and search for ssa</span></span></td><td class="benchmarkresult">3561410</td><td class="benchmarkresult">3767835</td><td class="benchmarkresult">3443667</td><td class="benchmarkresult">3869626</td><td class="benchmarkresult">3119903</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">std::unordered_map&lt;std::string, size_t> emplace &amp; find std::string_view;<span class="tooltiptext code">void HashMapStdStrView(benchmark::State&amp; state) {
    for (auto _: state) {
        std::unordered_map&lt;std::string, size_t> store;
        for (size_t idx = 0; idx &lt; bs_std.size(); idx++) {
            store.emplace(bs_std[idx], idx);
        }
#ifdef CHECK_RESULT
        if (store.size() != bs_std.size()) {
            state.SkipWithError(&quot;bad inserts&quot;);
        }
#endif
        for (size_t idx = 0; idx &lt; bs_std.size(); idx++) {
            std::string_view key = bs_std[idx];
            auto find = store.find(std::string{key});
            size_t res = find->second;
#ifdef CHECK_RESULT
            if (res != idx) {
                state.SkipWithError(&quot;bad find&quot;);
            }
#endif
            benchmark::DoNotOptimize(res);
        }
    }
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Вставляем std::string, а ищем std::string_view
We insert std::string and look for std::string_view</span></span></td><td class="benchmarkresult">4072390</td><td class="benchmarkresult">4195628</td><td class="benchmarkresult">6274459</td><td class="benchmarkresult">6233309</td><td class="benchmarkresult">3635000</td></tr>
</tbody></table></div><script>bench_sets['Hash Map insert and find'] = {id:'bs28', tests:[
{name:'hashStrMapA<size_t> emplace & find stringa;',data:[3707397,3720534,3812101,4223565,3100858]},
{name:'std::unordered_map<std::string, size_t> emplace & find std::string;',data:[3464746,3566994,5442291,5280639,3377674]},
{name:'hashStrMapA<size_t> emplace & find ssa;',data:[3561410,3767835,3443667,3869626,3119903]},
{name:'std::unordered_map<std::string, size_t> emplace & find std::string_view;',data:[4072390,4195628,6274459,6233309,3635000]}
]}</script>

<div class="benchset" id="bs29"><h4><a id="bs131384792586914680410" href="#bs131384792586914680410">#</a>&nbsp;Build Full Func Name</h4>
<table><thead><tr><th>Benchmark name</th><th width="5%">Comment</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), Clang-21</th><th width="8%">Xeon E5-2682 v4, Ubuntu 22 (WSL), GCC-13</th><th width="8%">Xeon E5-2682 v4, Windows 10, Clang-19</th><th width="8%">Xeon E5-2682 v4, Windows 10, MSVC-19</th><th width="8%">Xeon E5-2682 v4, WASM Firefox, Clang-21</th></tr></thead><tbody>
<tr><td class="benchmarkname"><span class="tooltip">Build func full name std::string;<span class="tooltiptext code">std::string build_full_name_std() const {
    std::string str{has_ret_type_resolver ? &quot;any&quot;sv : type_names_sv[(unsigned)ret_type]};
    str += &quot; &quot;;
    str += std_name;
    str += &quot;(&quot;;

    bool add_comma = false;

    for (const auto&amp; param : params) {
        if (add_comma) {
            str += &quot;, &quot;;
        }
        if (param.optional) {
            str += &quot;[&quot;;
        }
        param.allowed_types.to_stdstr(str);
        if (param.optional) {
            str += &quot;]&quot;;
        }
        add_comma = true;
    }
    if (unlim_params) {
        if (add_comma) {
            str += &quot;, &quot;;
        }
        str += &quot;...&quot;;
    }
    str += &quot;)&quot;;
    //std::cout &lt;&lt; &quot;Len=&quot; &lt;&lt; str.length() &lt;&lt; &quot;, Cap=&quot; &lt;&lt; str.capacity() &lt;&lt; &quot;\n&quot;;
    return str;
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Обыденная задача, подобные часто могут встретится в работе:
По неким данным сгенерировать текст. В этом случае по данным
о неких функциях сформировать их полное имя с типами параметров и
возвращаемого значения. Алгоритм на std::string.
A common task, similar to this one, can often be encountered in work:
Generate text from given data. In this case, using data
on certain functions, generate their full names with parameter types and
return values. The algorithm uses std::string.</span></span></td><td class="benchmarkresult">719</td><td class="benchmarkresult">1049</td><td class="benchmarkresult">1557</td><td class="benchmarkresult">1641</td><td class="benchmarkresult">2745</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Build func full name std::string 1;<span class="tooltiptext code">std::string build_full_name_std1() const {
    std::string str{has_ret_type_resolver ? &quot;any&quot;sv : type_names_sv[(unsigned)ret_type]};
    str += &quot; &quot; + std_name + &quot;(&quot;;

    bool add_comma = false;

    for (const auto&amp; param : params) {
        if (add_comma) {
            str += &quot;, &quot;;
        }
        if (param.optional) {
            str += &quot;[&quot;;
        }
        param.allowed_types.to_stdstr(str);
        if (param.optional) {
            str += &quot;]&quot;;
        }
        add_comma = true;
    }
    if (unlim_params) {
        if (add_comma) {
            str += &quot;, &quot;;
        }
        str += &quot;...&quot;;
    }
    str += &quot;)&quot;;
    //std::cout &lt;&lt; &quot;Len=&quot; &lt;&lt; str.length() &lt;&lt; &quot;, Cap=&quot; &lt;&lt; str.capacity() &lt;&lt; &quot;\n&quot;;
    return str;
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Почти тот же алгоритм, но несколько последовательных
+= к строке заменены на одно += + + +.
Almost the same algorithm, but several consecutive
+= to a string are replaced with a single += + + +.</span></span></td><td class="benchmarkresult">808</td><td class="benchmarkresult">1016</td><td class="benchmarkresult">1575</td><td class="benchmarkresult">1763</td><td class="benchmarkresult">2859</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Build func full name std::stream;<span class="tooltiptext code">std::string build_full_name_stream() const {
    std::ostringstream str;
    if (has_ret_type_resolver) {
        str &lt;&lt; &quot;any&quot;;
    } else {
        str &lt;&lt; type_names_sv[(unsigned)ret_type];
    }
    str &lt;&lt; &quot; &quot; &lt;&lt; std_name &lt;&lt; &quot;(&quot;;

    bool add_comma = false;

    for (const auto&amp; param : params) {
        if (add_comma) {
            str &lt;&lt; &quot;, &quot;;
        }
        if (param.optional) {
            str &lt;&lt; &quot;[&quot;;
        }
        param.allowed_types.to_stream(str);
        if (param.optional) {
            str &lt;&lt; &quot;]&quot;;
        }
        add_comma = true;
    }
    if (unlim_params) {
        if (add_comma) {
            str &lt;&lt; &quot;, &quot;;
        }
        str &lt;&lt; &quot;...&quot;;
    }
    str &lt;&lt; &quot;)&quot;;
    return str.str();
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Строим имя функции через std::ostringstream и <<
We construct the function name through std::ostringstream and <<</span></span></td><td class="benchmarkresult">2560</td><td class="benchmarkresult">2568</td><td class="benchmarkresult">8287</td><td class="benchmarkresult">9911</td><td class="benchmarkresult">6461</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Build func full name stringa;<span class="tooltiptext code">stringa build_full_name() const {
    lstringa&lt;512> str = e_choice(has_ret_type_resolver, &quot;any&quot;, type_names[(unsigned)ret_type]) + &quot; &quot; + name + &quot;(&quot;;

    bool add_comma = false;

    for (const auto&amp; param : params) {
        str += e_if(add_comma, &quot;, &quot;) + e_if(param.optional, &quot;[&quot;);
        param.allowed_types.to_simstr(str);
        if (param.optional) {
            str += &quot;]&quot;;
        }
        add_comma = true;
    }
    return str + e_if(unlim_params, e_if(add_comma, &quot;, &quot;) + &quot;...&quot;) + &quot;)&quot;;
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Реализация на simstr строках и строковых выражениях.
Инфа о параметрах добавляется в текущую строку
Implementation using simstr strings and string expressions.
Parameter information is appended to the current line.</span></span></td><td class="benchmarkresult">532</td><td class="benchmarkresult">460</td><td class="benchmarkresult">813</td><td class="benchmarkresult">910</td><td class="benchmarkresult">1302</td></tr>
<tr><td class="benchmarkname"><span class="tooltip">Build func full name stringa 1;<span class="tooltiptext code">stringa build_full_name1() const {
    lstringa&lt;512> str = e_choice(has_ret_type_resolver, &quot;any&quot;, type_names[(unsigned)ret_type]) + &quot; &quot; + name + &quot;(&quot;;

    bool add_comma = false;

    for (const auto&amp; param : params) {
        str += e_if(add_comma, &quot;, &quot;) + e_if(param.optional, &quot;[&quot;) + param.allowed_types.get_simstr() + e_if(param.optional, &quot;]&quot;);
        add_comma = true;
    }
    return str + e_if(unlim_params, e_if(add_comma, &quot;, &quot;) + &quot;...&quot;) + &quot;)&quot;;
}</span></span></td><td><span class="tooltip info">&nbsp;>>&nbsp;<span class="tooltiptext">Реализация на simstr строках и строковых выражениях.
Инфа о параметрах добавляется во временную строку, а потом
разом добавляется в текущую строку. Позволяет операции в цикле
записать в одну строку, но чуть проигрывает по времени выполнения.
Implementation using simstr strings and string expressions.
Parameter information is added to a temporary string, and then
all at once to the current string. This allows loop operations
to be written in a single string, but is slightly slower in execution time.</span></span></td><td class="benchmarkresult">669</td><td class="benchmarkresult">682</td><td class="benchmarkresult">940</td><td class="benchmarkresult">1009</td><td class="benchmarkresult">1478</td></tr>
</tbody></table></div><script>bench_sets['Build Full Func Name'] = {id:'bs29', tests:[
{name:'Build func full name std::string;',data:[719,1049,1557,1641,2745]},
{name:'Build func full name std::string 1;',data:[808,1016,1575,1763,2859]},
{name:'Build func full name std::stream;',data:[2560,2568,8287,9911,6461]},
{name:'Build func full name stringa;',data:[532,460,813,910,1302]},
{name:'Build func full name stringa 1;',data:[669,682,940,1009,1478]}
]}</script></body></html>